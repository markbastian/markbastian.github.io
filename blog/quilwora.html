<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quil, Clojure, and WORA</title>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
</head>
<body>
<main>
    <h3>Quil, Clojure, and WORA</h3>
    <h3>
        <small>July 14, 2015</small>
    </h3>
    <b>Introduction</b><br/>
    Since my last post, I've been playing with the excellent <a href="http://quil.info/">Quil library</a>, a
    "Clojure/ClojureScript library for creating interactive drawings and animations." Prior to this, I was writing
    demonstrations using the following scheme:<br/>
    <ol>
        <li>Develop all logic using cljc files (cljx before Clojure 1.7). In general, application logic is pretty
            platform-independent and can be wholly or nearly-wholly written in whatever language you are working in
            (Clojure in our case). Any slight variances (e.g. having to create a java.util.Date or a JavaScript Date)
            can easily be handled by <a href="http://dev.clojure.org/display/design/Reader+Conditionals">Clojure's new
                Reader Conditionals</a>.
        </li>
        <li>Decide on a UI technology (likely Java Swing with Java2D or HTML Canvas depending on what type of demo I
            wanted) and implement a front end using that particular choice.
        </li>
        <li>Optionally implement the "other" solution from #2 so that I now have a Java and JavaScript solution.</li>
    </ol>
    <div>
        This strategy works pretty well, but I still have duplication of effort when it comes to the user experience.
        The awesome thing about Quil is that it allows you to launch your UI as either a Clojure or ClojureScript
        application targeting the JVM or JavaScript-enabled browser, respectively. Now, I can pretty much write
        everything as cljc files with a few reader conditionals and easily produce targets that run on the JVM or in a
        browser.
    </div>
    <div>
        <br/></div>
    <div>
        To get my feet wet with Quil, I re-implemented the renderer for my <a
            href="http://fn-code.blogspot.com/2015/06/a-lunar-lander-game-in-clojure.html">Lunar Lander project</a> in
        Quil. I was so happy with the results that I removed the Canvas/ClojureScript renderer completely and now just
        use a single renderer for both the JVM and JS versions of the project.
    </div>
    <div>
        <br/></div>
    <div>
        <b>Results</b></div>
    <div>
        By the time I was done with my new rendering code and refactoring of everything else, all of the cljs files were
        gone. I now have a single clj file that is nothing more than a (:gen-class) macro and a main function calling
        the application entry point in the cljc code. Everything else is written as cljc files. Only a small number of
        reader conditionals were used to make any Clojure or ClojureScript specific changes as required. Rather than go
        over every example of how I used reader conditionals, take a look at <a
            href="https://github.com/markbastian/lander/blob/master/src/cljc/lander/game_launcher.cljc">this file</a>
        that demonstrates how to create a single Quil "Sketch" that works with both host platforms. Aside from the above
        linked file, the only other conditionals required were a couple java.util.Date vs. JavaScript Date conditionals
        used in the simulation namespace. The vast majority of the code was identical for all hosts.
    </div>
    <div>
        <br/></div>
    <div>
        <b>Conclusion</b></div>
    <div>
        I've been developing code for the JVM for over 10 years and have always liked the "Write once, run anywhere"
        (WORA) aspect of JVM languages, and have found that WORA works for the most part. However, you can't always rely
        on your host machine having a modern JVM, especially in the era of mobile devices. The browser is really the
        most ubiquitous host platform, and the ability to write a single application that can be compiled to run as a
        JVM app or a JavaScript app with very little effort is a huge advantage for Clojure and Clojurists.
    </div>
    <div>
        <br/></div>
    <div>
        <b>Afterthoughts</b></div>
    <div>
        The complete application described in this blog can be found <a href="https://github.com/markbastian/lander">here</a>.
        Note that you will need to build and install my <a href="https://github.com/markbastian/numerics">numerics</a>
        project as well. Once numerics is installed, cd over to lander and type <i>lein run</i> for the Clojure version
        of the game. You can play the web version right here (Note that you will need a keyboard or some way to emulate
        the 'f' key and left and right arrow keys.).
    </div>
    <div>
        <br/></div>
    <div class="container">
        <canvas height="400" id="quil-lander-canvas" style="border: 1px solid #000000;" width="400"></canvas>
    </div>
    <script src="../quil-lander/js/lander.js"></script>
    <script type="text/javascript">lander.game_launcher.launch_app(document.getElementById("quil-lander-canvas"), 400, 400);</script>
</main>
</body>
</html>