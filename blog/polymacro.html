<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Polynomials in Clojure</title>
    <!-- MathJax. -->
    <!-- http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference -->
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
    <script type="text/javascript" async
            src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css" />
</head>
<body>
<main>
    <h6><a href="./index.html">Blog Index</a></h6>
    <h1>
        Polynomials and Macros
        <small>December 17, 2016</small>
    </h1>

    <p>Polynomials are common functions of the form:</p>

    \(p(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \dotsb + a_nx^n\)

    <p>Evaluating a polynomial in this form takes n additions and \(\frac{(n^2 + n)}{2}\) multiplications.
        A more efficient, but not as common (At least when you are doing math by hand), form of expressing the same
        polynomial is the Horner form, which takesonly n additions and multiplications:</p>

    \(p(x) = a_0 + x(a_1 + x(a_2 + \dotsb + x(a_{n-1} + a_nx)))\)

    <p>An function for evaluating polynomials in Horner form in Clojure looks like this:</p>

    <pre><code class="language-klipse">
        (ns poly.core$macros)
(defn horner [t c] (reduce #(+ (* t %1) %2) (rseq c)))
</code></pre>

    <p>Let's give it a shot. For this exercise, I will be using terms from the equation describing nutation (a perturbation
        of the Earth's rotation) due to the Moon. See "Fundamentals of Astrodynamics and Applications" by David Vallado
    if you want to learn more.</p>
    <pre><code class="language-klipse">
(horner 0.0426236319 [134.96340251 477198.8675605 0.0088553 1.4343E-5])
</code></pre>

    <p>If you are going to be calling this nutation function a lot, you'll probably want to define a function for it.</p>

    <pre><code class="language-klipse">
(defn lm-horner [t] (horner t [134.96340251 477198.8675605 0.0088553 1.4343E-5]))
(lm-horner 0.0426236319)
</code></pre>

    <p>One thing I wondered was how the performance differed between using Horner's algorithm and directly evaluating
        the polynomial in Horner form. If the former polynomial were in Horner form, it would look like what you see
    here. I'm just manually performing the expansion without the overhead of the call to reduce. It's ugly and manually
    typing all of those terms in can be very error-prone, but I'm interested in seeing how the performance differs.</p>

    <pre><code class="language-klipse">
(defn lm-direct [t]
  (+ 134.96340251 (* (+ 477198.8675605 (* (+ 0.0088553 (* 1.4343E-5 t)) t)) t)))
(lm-direct 0.0426236319)
</code></pre>

    <p>Now let's see how long it takes to call the two versions:</p>

<pre><code class="language-klipse">
(prn "Horner's Method:")
(dotimes[_ 10] (time (lm-horner 0.0426236319)))
(prn "Horner Form:")
(dotimes[_ 10] (time (lm-direct 0.0426236319)))
</code></pre>

    <p>They both seem about the same, but the direct method becomes essentially immeasurable. What if I use different
    values?</p>

<pre><code class="language-klipse">
(def r (vec (repeatedly 10 rand)))
(prn "Horner's Method:")
(dotimes[i 10] (time (lm-horner (r i))))
(prn "Horner Form:")
(dotimes[i 10] (time (lm-direct (r i))))
</code></pre>

    <p>At this point, it would appear that defining your polynomials using Horner's method is the way to go. I was hoping
        to show that the Horner form was much better, but alas, reduce must be pretty efficient. Had my original hypothesis
        been correct, I would have shown you this really cool macro I wrote that gives you the best of both worlds. Since I
        wrote it anyways, I am still going to talk about it.</p>

    <p>Suppose you really wanted the simplicity of defining a polynomial using a vector of coefficients  but under the
    hood you wanted everything fully expanded out? You could do this with the following very cool macro:</p>

    <pre><code class="language-klipse">
(defmacro defpoly [n terms]
  `(defn ~n [~'t]
     ~(reduce (fn [b a] `(~'+ ~a (~'* ~b ~'t)))
              (rseq terms))))
</code></pre>

    <p>defpoly takes a symbol (the name of your polynomial) and a vector of coefficients and defines the function using
    the full Horner form of the polynomial. You can see it in action right here:</p>

    <pre><code class="language-klipse">
(macroexpand '(poly.core/defpoly p [1 2 3]))
</code></pre>

<p>Here's our nutation function, defined using our macro:</p>

<pre><code class="language-klipse">
(poly.core/defpoly lm-macro [134.96340251 477198.8675605 0.0088553 1.4343E-5])
(lm-macro 0.0426236319)
</code></pre>

    <p>Again, we'll profile it using our completely non-scientific technique:</p>

<pre><code class="language-klipse">
(prn "Macro definition - same argument:")
(dotimes[_ 10] (time (lm-macro 0.0426236319)))
(prn "Macro definition - random arguments:")
(dotimes[i 10] (time (lm-macro (r i))))
</code></pre>

<p>Conclusions</p>
    <p>In this exercise, I explained efficient polynomial evaluation and tried a few techniques to see if some were
    noticeably different than others. </p>

</main>
</body>

<!--<link rel="stylesheet" type="text/css" href="http://app.klipse.tech/css/codemirror.css" />-->
<link rel="stylesheet" type="text/css" href="../resources/css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../resources/css/monokai.css" />

<script>
    window.klipse_settings = {
        selector: '.language-klipse'// css selector for the html elements you want to klipsify
    };
</script>

<script>window.klipse_settings = {selector: '.language-klipse'};</script>
<!--<script src="http://app.klipse.tech/plugin/js/klipse_plugin.js"></script>-->
<script src="../resources/js/klipse_plugin.js"></script>

</html>