<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clojure is Homoiconic, Java is Not</title>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
    <link rel="stylesheet" href="../bower_components/highlightjs/styles/zenburn.css">
    <script src="../bower_components/highlightjs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<main>
    <h3>Clojure is Homoiconic, Java is Not</h3>
    <h3>
        <small>August 6, 2015</small>
    </h3>
    <b><span style="font-family: Arial, Helvetica, sans-serif;">Introduction</span></b><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;">Recently I was reading this <a
            href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html">article</a> regarding what is (or was) new in Java 8 and&nbsp;took an interest in the following section on Lambdas:</span><br/>
    <blockquote class="tr_bq">
        <span style="font-family: Arial, Helvetica, sans-serif; line-height: 16px;">Lambda Expressions, a new language feature, has been introduced in this release. They enable you to treat functionality as a method argument, or code as data. Lambda expressions let you express instances of single-method interfaces (referred to as functional interfaces) more compactly.</span>
    </blockquote>
    <span style="font-family: Arial, Helvetica, sans-serif;">I did a quick <a
            href="https://www.google.com/search?q=java%20lambdas">Google search</a> on "java lambdas" and <a
            href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">this tutorial was the first hit</a>. Once again, the same type of statement is made:</span><br/>
    <blockquote class="tr_bq">
        <span style="font-family: Arial, Helvetica, sans-serif; line-height: 19px;">One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.</span>
    </blockquote>
    <span style="font-family: Arial, Helvetica, sans-serif;">The thing that struck me about these articles is the consistent statement that that Java Lambdas (a.k.a. anonymous instances of single method interfaces) are "code as data"&nbsp;because the function can be passed as an argument. I guess if you define data as "instances of classes or functions" then this description is fine, but when I read these articles this is what comes to mind:</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <br/>
    <div class="separator" style="clear: both; text-align: center;">
        <a href="../resources/images/codeasdata.jpg"
           imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span
                style="font-family: Arial, Helvetica, sans-serif;">
            <img border="0" height="240" src="../resources/images/codeasdata.jpg" width="320"/></span></a></div>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Technically, the ability to assign a function to a variable or pass a function as an argument to another function means that your functions are "first class" which is a good thing. However, I would not call this "code as data." Another related term is "higher order functions." These are functions that take functions as their arguments or return functions as their results. Again, this is a very powerful language feature that Java now sort of does, but this is not "code as data."</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">What do I think of when I think of "code as data?" I think of "Homoiconicity." Google seems to agree, since when I type <a
            href="https://www.google.com/search?q=code%20as%20data">"code as data" into a search box</a> the first thing that comes up is <a
            href="https://en.wikipedia.org/wiki/Homoiconicity">this Wikipedia article on Homoiconicity</a>. Let's explore the concept in more detail.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <b><span style="font-family: Arial, Helvetica, sans-serif;">What is Homoiconicity?</span></b><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;">Often homoiconicity is defined one the following ways:</span><br/>
    <ul>
        <li><span style="font-family: Arial, Helvetica, sans-serif;">The code is written in the data structures of the language.</span>
        </li>
        <li><span style="font-family: Arial, Helvetica, sans-serif;">Code as data.</span></li>
    </ul>
    <div>
        <span style="font-family: Arial, Helvetica, sans-serif;">Those more familiar with the concept seem to use "Code as data" more, but I think the first definition is a bit more clear if you are getting started with the idea. Either way, I am going to illustrate the concept by showing how Clojure code is actually written as Clojure data structures. To contrast, I'll also show what "homoiconic Java" would look like. Finally, I'll show you a simple Clojure macro in which we rearrange our code/data.</span>
    </div>
    <div>
        <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
        <b><span style="font-family: Arial, Helvetica, sans-serif;">Homoiconic Clojure</span></b></div>
    <div>
        <span style="font-family: Arial, Helvetica, sans-serif;">To start, consider the following core Clojure data structures:</span>
    </div>
    <div>
        <ul>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">() is an empty List.</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">{} is an empty Map.</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">[] is an empty Vector.</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">#{} is an empty Set.</span></li>
        </ul>
        <span style="font-family: Arial, Helvetica, sans-serif;">When we write code in Clojure, it is expressed in terms of the above data structures. Here is a very simple example that applies the str function (it's kind of like .toString) to the number 42:</span>
    </div>
    <div>
<pre><code>user=&gt; (str 42)
"42"</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">You might look at this and think this is the same as the following Java code:</span><br/>
    <div>
<pre><code>public static String str(Integer i){
    return i.toString();
}

str(42);
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">The only difference is the location of the parenthesis, right? Wrong! (str 42) not actually the function str with the argument of 42, but is a list containing two elements, the str symbol and the value 42. When the Clojure evaluator sees a list it attempts to resolve the first symbol (str in this case) and calls that function with the remaining elements of the list as arguments. While this may seem like splitting hairs at the moment, this is very important when you get to macros. It is also crucial to the point that Clojure code is data.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Here's another one:</span><br/>
    <div>
        <pre><code>(defn add [a b](+ a b))</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">Again, you might think this is the same thing as this Java function:</span><br/>
    <div>
<pre><code>public static int add(int a, int b){
    return a + b;
}</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">As before, they are not the same. The above Clojure add function is actually built up with two lists (one nested) and a vector of arguments. The inner list contains three symbols (+, a, and b) and the outer list contains the defn symbol, a symbol naming your function ("add"), a vector of arguments, and our inner list.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Here's another example:</span><br/>
    <div>
<pre><code>(merge-with + { :x 1 :y 2 :z 3 } { :x 9 :y 2 :z 4 })
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">By this point you should see that we have a list, two maps, and a bunch of symbols and values as opposed to a function that adds two maps. Yes, the evaluator will merge the maps, but the code itself is data (as in the native data structures of the language).</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">You can do this type of structural breakdown with any Clojure code. Clojure programs are literal data structures consisting of nested literal data structures, values, and symbols. For more details, read <a
            href="http://clojure.org/evaluation">this</a>. The key takeaway is that we are indeed writing our code as a bunch of data (literal data structures containing nested data structures, values, and symbols).</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <b><span style="font-family: Arial, Helvetica, sans-serif;">Homoiconic Java</span></b><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;">What if you wanted to write Java in its own data structures?</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Here are our Java collection interfaces that correspond to the Clojure ones above:</span><br/>
    <div>
        <ul>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">java.util.List</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">java.util.Map</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">java.util.Vector</span></li>
            <li><span style="font-family: Arial, Helvetica, sans-serif;">java.util.Set</span></li>
        </ul>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">Java, for some inexplicable reason, does not yet have collection literals, so this will be a very verbose exercise. My apologies up front.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <br/>
    <div class="separator" style="clear: both; text-align: center;">
        <a href="../resources/images/CollectionLiterals.jpg"
           imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><span
                style="font-family: Arial, Helvetica, sans-serif;">
            <img border="0" height="320" src="../resources/images/CollectionLiterals.jpg" width="240"/></span></a></div>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Ok, now let's write some Java code in the data structures of the language:</span><br/>
    <div>
<pre><code>    List add = new LinkedList();
    add.add("+");
    add.add(1);
    add.add(1);
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">Sadly, I have no way to evaluate this code, but, hey, it's data. I chose to use a String to represent the + operation because Java doesn't have symbols, either.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Here's another attempt at how I might construct some code as data in Java. I realize that this will be an utter failure, but you're just going to have to follow along as I write a ton of code to make my point.</span><br/>
    <div>
<pre><code>    Map a = new HashMap();
    a.put("x", 1);
    a.put("y", 2);
    a.put("z", 3);

    Map b = new HashMap();
    b.put("x", 9);
    b.put("y", 2);
    b.put("z", 4);

    List mergemaps = new LinkedList();
    add.add("merge-with");
    add.add("+");
    add.add(a);
    add.add(b);
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">Again, this can't be evaluated, but it's about as close as you can get to homoiconicity in Java.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <b><span style="font-family: Arial, Helvetica, sans-serif;">Why Homoiconicity? - Macros</span></b><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;">Consider this question: "What can you do with data?" Think about an Excel spreadsheet, a simple comma separated value file, or some JSON data. These are things you can easily sort, manipulate, and transform.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">In the same way, Clojure code can be manipulated and transformed as data. In Clojure there is a facility for this called a macro. When Clojure evaluates macros, it does not evaluate the arguments as with a regular function. Rather, it passes the unevaluated arguments into the macro to be manipulated. Once this is done, the result is returned and evaluated.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Here's an example:</span><br/>
    <div>
<pre><code>(defmacro bizzaro-math
  "Do everything the opposite of normal"
  [[op &amp; rest]]
  (conj rest (case op
               + -
               - +
               * /
               / *
               op)))
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">This macro takes its arguments and inverts the first argument if it is a basic arithmetic operator. Note that this would not be possible if the arguments were evaluated rather than treated as data. Here are some examples of it in use:</span><br/>
    <div>
<pre><code>(bizzaro-math (+ 2 3))
=&gt; -1
(bizzaro-math (- 2 3))
=&gt; 5
(bizzaro-math (* 2 3))
=&gt; 2/3
(bizzaro-math (/ 2 3))
=&gt; 6
(bizzaro-math (rem 2 3))
=&gt; 2
</code></pre>
    </div>
    <span style="font-family: Arial, Helvetica, sans-serif;">The most important thing to note here is that the inner forms (e.g. (+ 2 3)) are not evaluated, but are manipulated by the macro, then evaluated. This is the ultimate demonstration that we do, indeed, have code as data.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">A more in-depth discussion of macros is beyond the scope of this post, but the main takeaway is that macros allow you to manipulate code. This is a feature unique to homoiconic languages.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <b><span style="font-family: Arial, Helvetica, sans-serif;">Parting Thoughts</span></b><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;">Code as data, a.k.a. homoiconicity, is the ability to write your code in the data structures of your language. This goes way beyond the simple ability to pass a function as an argument. If that's all you are looking for, Java might be all you need. If you want full on FP on the JVM, you've got better options. Scala is a great bridge language that has first class functions, higher order functions, partial evaluation, composition, and all the other things you'd expect from a&nbsp;functional language. Clojure, however, is King if want it all. Not only is it functional, it is truly homoiconic.</span><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><br/></span>
    <span style="font-family: Arial, Helvetica, sans-serif;">Further Reading:</span><br/>
    <a href="http://www.paulgraham.com/avg.html"><span style="font-family: Arial, Helvetica, sans-serif;">Beating the Averages</span></a><br/>
    <span style="font-family: Arial, Helvetica, sans-serif;"><a
            href="http://www.braveclojure.com/read-and-eval/#5__Macros">Clojure For the Brave and True</a></span><br/>
    <a href="http://clojure.org/macros"><span
            style="font-family: Arial, Helvetica, sans-serif;">Clojure Macros</span></a><br/>
    <br/>
</main>
</body>
</html>