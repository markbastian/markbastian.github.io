<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three Reasons You May Not Want to Learn Clojure</title>
    <link rel="stylesheet" type="text/css" href="../resources/css/style.css"/>
</head>
<body>
<main>
    <h3>Three Reasons You May Not Want to Learn Clojure</h3>
    <h3>
        <small>July 22, 2015</small>
    </h3>
    <b>Introduction</b><br/>
    I've been coding in Clojure for over a year now and not everything is unicorns and rainbows. Whatever language you
    choose will affect how you think and work and Clojure is no different. Read on to see what some of these effects are
    and why you might want to reconsider learning Clojure.<br/>
    <br/>
    <b>1. You will write at least 10X less code than your Java counterparts</b><br/>
    Often, the measure of a library or project is its size. Programmers like to compare the size of their projects, just
    like muscle car people like to compare the size of their engines. Here are some situations where this might
    happen:<br/>
    <ul>
        <li>Lunch with buddies</li>
        <li>Job interview</li>
        <li>Internal performance evaluation</li>
    </ul>
    Here's a typical conversation:<br/>
    <br/>
    You: "Yeah, I just finished delivering the Awesome 2000."<br/>
    Them: "Oh, yeah? Tell me about it."<br/>
    You: "Well, it is this software product that simultaneously creates world peace, solves world hunger, and saves the
    environment. Zero carbon footprint, too."<br/>
    Them: "Cool, how many lines of code was that?"<br/>
    You: "Oh, like 2 million."<br/>
    Them: "Wow, awesome."<br/>
    <br/>
    You will now get a high five, a job offer, or a big raise depending on who you are talking with. However, if you
    stated that the number of lines of code in your product was 200 then the response might be more along the lines of
    "Oh, a toy program written in a toy language." For some reason, probably because it is easy, many people like to
    equate lines of code with programming ability rather than some other metric like, oh, I don't know, the actual
    features of the programs you've developed. Clojure, sadly, excels at implementing features but is very poor at being
    verbose about it.<br/>
    <br/>
    If you want to demonstrate your ability to code by writing lots of it, Clojure is a terrible, horrible, no-good
    language. I can't think of another language that is worse in this respect. You will never be able to brag again, in
    an circumstance, about how big your code base is compared to someone else's.<br/>
    <br/>
    <b>2. You won't be marketable for certain jobs</b><br/>
    True Story: Once upon a time I was at a job interview and the interview panel asked me to go up to the board and
    code up a Fibonacci sequence generator. I asked what language they wanted it in and they said they didn't care, but
    they were a C++ shop. Since they didn't care, I wrote a very short tail-recursive Scala version which I am sure they
    found incomprehensible. I used to program in C++ and at one time I think I was quite good at it. However, I am just
    not that interested in C++ any more. It was a great job interview because I didn't get the job. I am sure that the
    story would have ended the same had I done the exercise in Clojure, except for the parenthesis would have been in
    the right place.<br/>
    <br/>
    If you want to be a professional Clojure programmer, there will be a smaller number of job openings for someone of
    your skills and interests than for the standard Java or C# developer. If you are interested in being part of a clone
    army doing widely-available boring work, Clojure is not for you.<br/>
    <br/>
    <b>3. You will get things done faster</b><br/>
    Clojure makes you productive, really productive. So, if you can get a product to market 3-10 times faster than you
    once could, what does your employer do with all that extra time you just bought them? Fire you and pocket the
    savings, that's what! Just kidding. Mostly.<br/>
    <br/>
    While it is true that a company might take advantage of their newfound savings in cost and time by eliminating the
    software team that just bought them the savings, the more likely scenario is that 1) they will reapply you to
    something else; or 2) if they are trimming fat, you aren't part of it. Often you will become the new go-to person
    for getting things done because you've demonstrated an ability to get things done. This does lead to problem 3a: You
    have too much work to do because you are a productivity magnet.<br/>
    <br/>
    While you can't predict what your employer will do in a given situation, one constant you can be sure of in the
    current software job market is that you must be agile. If you demonstrate value you can be sure that will have the
    opportunity to continue to demonstrate value. If, on the other hand, you resist change you will eventually be phased
    out by your own employer or by another company that displaces yours entirely.<br/>
    <br/>
    <b>Conclusion</b><br/>
    Yes, Clojure is an enabling and empowering language, but this is not without its down sides. I didn't even get into
    some of the other issues, like not having the opportunity to rewrite your Java code in JavaScript because Clojure
    compiles both ways. If these are the kinds of problems you like to deal with, you just might want to give Clojure a
    try.<br/>
    <br/>
    <b>Shameless Plug</b><br/>
    Like this blog? Please share, subscribe, or follow it (just enter your email at the top right).
</main>
</body>
</html>