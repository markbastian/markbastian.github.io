<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://markbastian.github.io" rel="self" type="application/rss+xml"/><title>(conj community thoughts)</title><link>https://markbastian.github.io</link><description>Thoughts on Clojure, Functional Programming, and the like</description><lastBuildDate>Fri, 03 Jul 2020 12:04:52 -0600</lastBuildDate><generator>clj-rss</generator><item><guid>https://markbastian.github.io/posts-output/2017-07-10-polymacro/</guid><link>https://markbastian.github.io/posts-output/2017-07-10-polymacro/</link><title>A Polynomial Macro</title><description>IntroductionIn this edition of the blog I am going to cover a very cool macro for conveniently defining polynomials that is also very performant. It's also a great example of how macros work and when you might want to use one.</description><pubDate>Mon, 10 Jul 2017 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2017-06-19-clojure-rising/</guid><link>https://markbastian.github.io/posts-output/2017-06-19-clojure-rising/</link><title>Clojure Rising</title><description>#Still Here, Still Doing Clojure
It's been a while since I've added to my blog over at fn-code. If you were to speculate
that this is because I am no longer a Clojurian, you would be very wrong. In fact, from my perspective Clojure adoption and
usage is alive, well, and growing in both my own life and in the community.As far as the lack of blogging goes, here's a summary of what's been going on with me:</description><pubDate>Mon, 19 Jun 2017 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2016-04-07-tetris/</guid><link>https://markbastian.github.io/posts-output/2016-04-07-tetris/</link><title>Another Tetris Clone in Clojure</title><description>##Introduction
Recently I was looking at a problem involving extracting and transposing submatrices of data within a larger data grid. Somehow this got me thinking how easy it would be to rotate tetrominos using Clojure. In case you are wondering, it is super easy:</description><pubDate>Thu, 07 Apr 2016 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-10-26-concerns/</guid><link>https://markbastian.github.io/posts-output/2015-10-26-concerns/</link><title>My Concern with Concerns</title><description>##Introduction
In the Computer Science world we often talk about the value of Separation of Concerns (SoC). This Wikipedia article on the subject says that well-separated code is more modular, maintainable, and reusable. The basic idea is that we separate our code into components by their roles so that those pieces can be used and developed independently as well as assembled into a greater whole.However, I am concerned with the traditional treatment of concerns. We often look at concerns as a breakdown of our application into various interconnected pieces, or objects. For example, you might have a game program with a rendering system, an input system, a physics system, and so on. A spreadsheet application might have concerns regarding computations, persistence, and input. At a high level, and borrowing from the Wikipedia article, you might have concerns for things like business logic, persistence, data access, and presentation.</description><pubDate>Mon, 26 Oct 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-08-25-snake/</guid><link>https://markbastian.github.io/posts-output/2015-08-25-snake/</link><title>A Clojure Snake Game</title><description>IntroductionI recently decided to write a Snake game in Clojure as a small project. In the game you have a snake that grows as it consumes food. The goal of the game is to make the snake as long as possible without self-intersecting. I got the idea to do it on a Saturday morning and by that night I was done. Most of the coding was done in the evening since I was doing family activities all day. All told, this was probably a 3 hour project. The entire program is 75 lines of code. That's awesome! This includes both the JVM and JavaScript targets via Clojure and ClojureScript.
Here's the game:</description><pubDate>Tue, 25 Aug 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-08-06-homoiconic/</guid><link>https://markbastian.github.io/posts-output/2015-08-06-homoiconic/</link><title>Clojure is Homoiconic, Java is Not</title><description>IntroductionRecently I was reading this article regarding what is (or was) new in Java 8 and took an interest in the following section on Lambdas:</description><pubDate>Thu, 06 Aug 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-07-22-three/</guid><link>https://markbastian.github.io/posts-output/2015-07-22-three/</link><title>Three Reasons You May Not Want to Learn Clojure</title><description>IntroductionI've been coding in Clojure for over a year now and not everything is unicorns and rainbows. Whatever language you choose will affect how you think and work and Clojure is no different. Read on to see what some of these effects are and why you might want to reconsider learning Clojure.</description><pubDate>Wed, 22 Jul 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-07-14-quilwora/</guid><link>https://markbastian.github.io/posts-output/2015-07-14-quilwora/</link><title>Quil, Clojure, and WORA</title><description>IntroductionSince my last post, I've been playing with the excellent Quil library, a "Clojure/ClojureScript library for creating interactive drawings and animations." Prior to this, I was writing demonstrations using the following scheme:</description><pubDate>Tue, 14 Jul 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-06-24-lander/</guid><link>https://markbastian.github.io/posts-output/2015-06-24-lander/</link><title>A Lunar Lander Game in Clojure</title><description>IntroductionIn a prior post, I spent a great deal of time talking about Predator-Prey systems, ordinary differential equations, and solving these equations in Clojure. In this post, I describe a recent project I did that uses the same ODE solver to do something much more fun - implement a physics-based lunar lander game.</description><pubDate>Wed, 24 Jun 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-06-11-differences/</guid><link>https://markbastian.github.io/posts-output/2015-06-11-differences/</link><title>Differences between Null, Nil, nil, Some, and None</title><description>IntroductionDuring a recent code review, a coworker who had the good fortune of jumping straight from
Java to Clojure was asking me a few questions about some Scala code she'd been asked to edit.
The particular problem involved recursive accumulation of some list data and our conversation
drifted towards some questions regarding the different-yet-similar-sounding terms in these JVM
languages. Java, Scala, and Clojure together have Null, Nil, nil, Some, and None. Most of these
are related in their respective languages to how exceptional behaviors are handled with respect
to references and/or collections. Here I explain each of these from the perspective of their host
languages and my opinion of the effectiveness of each solution.</description><pubDate>Thu, 11 Jun 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-05-27-exercises/</guid><link>https://markbastian.github.io/posts-output/2015-05-27-exercises/</link><title>Exercises in Clojure with Commentary</title><description>IntroductionI was recently browsing some links from my Twitter feed and came across some programming exercises and their solutions. I selected a few that I thought were interesting, solved them, and now I want to present my solutions here along with some commentary on how they were solved. I think the solutions and especially their comments might be helpful to new Clojurists as well as Java developers who are looking for some examples of why Clojure code is so much more concise. Without further ado, here they are.</description><pubDate>Wed, 27 May 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-05-15-fpfirehose/</guid><link>https://markbastian.github.io/posts-output/2015-05-15-fpfirehose/</link><title>Functional Programming from the Fire Hose</title><description>Earlier this year I gave a presentation at work entitled "Functional Programming (FP) from the Fire Hose."
My goal was to present, to a mostly OOP audience, some of the basics of FP while also providing examples that show
that FP isn't just academic. You can't sell people on FP with concepts alone. People's eyes just glaze over and roll
back into their heads when you start talking functional concepts like first class and higher order functions,
immutability, statelessness, referential transparency, homoiconicity, and the like (I won't even say the M-word).
With that in mind, I tried to go fast on FP and show several clear examples that demonstrate FP in action, even at a
very small scale.In my presentation, I do (or attempt to do) the following:</description><pubDate>Fri, 15 May 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-04-28-predator-prey/</guid><link>https://markbastian.github.io/posts-output/2015-04-28-predator-prey/</link><title>Predator-Prey Modeling in Clojure</title><description>Introduction to Predator-Prey SystemsIn this edition of the blog, I'll discuss how you can use Clojure to solve a system of nonlinear differential equations.
he particular system I'll be solving is the Predator-Prey or Lotka-Volterra Model, which you can read all about right
here. The basic concept is that you are modeling a population of predators and prey (e.g. Foxes and Rabbits, which we'll use here). How the two populations change over time can be modeled like so:</description><pubDate>Tue, 28 Apr 2015 00:00:00 -0600</pubDate></item><item><guid>https://markbastian.github.io/posts-output/2015-04-11-mazes/</guid><link>https://markbastian.github.io/posts-output/2015-04-11-mazes/</link><title>A-maze-ing Mazes with Clojure</title><description>IntroductionMazes can be pretty fun. Children love them. Add a dungeon theme (e.g. monsters, loot, and a dragon boss) and most computer programming adults like them, too.</description><pubDate>Sat, 11 Apr 2015 00:00:00 -0600</pubDate></item></channel></rss>