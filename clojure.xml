<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://markbastian.github.io' rel='self' type='application/rss+xml'/>
<title>
(conj community thoughts)
</title>
<link>
https://markbastian.github.io
</link>
<description>
Thoughts on Clojure, Functional Programming, and the like
</description>
<lastBuildDate>
Sun, 19 Aug 2018 23:19:13 -0600
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://markbastian.github.io/posts-output/2017-07-10-polymacro/
</guid>
<link>
https://markbastian.github.io/posts-output/2017-07-10-polymacro/
</link>
<title>
A Polynomial Macro
</title>
<description>
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;&lt;p&gt;In this edition of the blog I am going to cover a very cool macro for conveniently defining polynomials that is also very performant. It's also a great example of how macros work and when you might want to use one.&lt;/p&gt;&lt;h2 id=&quot;polynomials&quot;&gt;Polynomials&lt;/h2&gt;&lt;p&gt;In mathematics, a polynomial is a function of the form:&lt;/p&gt;&lt;p&gt;\(p(x) = a_0 + a_1x + a_2x ^2 + a_3x ^3 + \dotsb + a_nx ^n\)&lt;/p&gt;&lt;p&gt;This particular representation is called the &lt;i&gt;canonical form&lt;/i&gt;.&lt;/p&gt;&lt;p&gt;Evaluating a polynomial in canonical form takes n additions and \(\frac{(n ^2 + n)}{2}\) multiplications.&lt;/p&gt;&lt;p&gt;A more efficient form of expressing the same polynomial is the &lt;a href=&quot;https://reference.wolfram.com/language/ref/HornerForm.html&quot;&gt;Horner form&lt;/a&gt;, which takes only n additions and multiplications:&lt;/p&gt;&lt;p&gt;\(p(x) = a_0 + x(a_1 + x(a_2 + \dotsb + x(a_{n-1} + a_nx)))\)&lt;/p&gt;&lt;p&gt;In Clojure, here is how you'd write a polynomial in both canonical and Horner forms:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(ns poly.core$macros
  (:require [cljs.js :as cljs]))

(defn poly-canonical [t]
  (+ 134.96340251  
     (* t 477198.8675605) 
     (* t t 0.0088553) 
     (* t t t 1.4343E-5)))

(defn poly-horner [t]
  (+ 134.96340251
     (*
       (+ 477198.8675605
          (* 
            (+ 0.0088553
               (* 1.4343E-5 t)) 
            t)) 
       t)))

;Either form gives the same result
[(poly-canonical 0.0426236319) (poly-horner 0.0426236319)]
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I believe the canonical form is easer to read and code, but the Horner form should run faster as there are less operations involved. In this case, n is only 3, so there are 9 arithmetic operations for the canonical formula and 6 for the Horner. If you were to profile them you'd probably not see any distinguishable difference between the two.&lt;/p&gt;&lt;p&gt;You should see larger differences in performance with higher n, but at this point in the post I have no way to create a large polynomial other than hand coding it, so I'll defer that task for now.&lt;/p&gt;&lt;p&gt;As for demonstrating the relative performance of the functions I'll be developing, we'll use the &lt;code&gt;rank&lt;/code&gt; function below.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(defn time-fn[n-samples f]
(let[t0 (.now js/performance)
     _ (dotimes[_ n-samples] (f))]
  (- (.now js/performance) t0)))
  
(defn normalize-scores [res]
  (let[[[_ b ] :as v] (sort-by second res)]
        (mapv (fn[[k v]] [k (/ v b)]) v)))

(defn rank[n &amp;amp; args]
  (loop[[k f &amp;amp; r] args res []]
    (if (and k f)
      (recur r (conj res [k (time-fn n f)]))
      (normalize-scores res))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that we've got our comparison function, let's try it out:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(rank
  1000 
  :canonical #(poly-canonical 0.0426236319)
  :horner #(poly-horner 0.0426236319))
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Take some time to play around with the number of samples here. I've intentionally used lower numbers in this post so the klipse workspace won't take forever to load. You will likely see the Horner form slightly outperform the canonical method for large sample sizes, but sometimes you may see the canonical form do better. Remember, the order of this polynomial is pretty low and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;&lt;code&gt;(.now js/performance)&lt;/code&gt; method is only accurate to 5 Î¼s&lt;/a&gt;, so take the exact ranking with a grain of salt. We really won't see large relative differences until we start using larger samples and compare functions with much larger performance differences.&lt;/p&gt;&lt;p&gt;Either way, it's kind of kludgy to type out each polynomial by hand and the process can be error prone. You need to make sure you type everything in correctly, get the term ordering right, and so on. This particular polynomial has all positive coefficients which makes transcription easier, but many polynomials have both positive and negative coefficients. When this happens, you need to exercise care to not mess up the signs along with transcribing all of the digits correctly, too.&lt;/p&gt;&lt;p&gt;It would be much easier to just express your polynomials as a sequence of coefficients that are used as a function argument, like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;See the footnote if you want to know where these numbers come from.
(def c [134.96340251 477198.8675605 0.0088553 1.4343E-5])
 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;By defining the coefficients independently of polynomial evaluation or generation your only concern when defining a new polynomial is getting the coefficients correct. Furthermore, this is a good storage format. Suppose you had coefficient data in Excel. All you'd need to do is copy and paste into a vector. No hand coding of polynomials required.&lt;/p&gt;&lt;p&gt;Here are corresponding functions for evaluating a polynomial given a coefficient vector. Interestingly (and conveniently), the more efficient Horner form is also simpler to code.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;Evaluation in canonical form.
(defn eval-canonical [t cs]
  ;Not sure which is a better canonical implementation here (for comparison purposes)
  ;Simpler, but does pow actually do i multiplies under the covers 
  ;(since I am trying to reproduce the behavior of the equation above)?
  ;(reduce + (map-indexed (fn[i c](* c (Math/pow t i))) cs))
  ;Guaranteed i operations for true comparison purposes, but more 'stuff' to make it happen
  (reduce + (map-indexed (fn[i c] (apply * (cons c (repeat i t)))) cs)))
      
;Horner polynomial evaluation
(defn eval-horner [t c]
  (reduce #(+ (* t %1) %2) (rseq c)))

;Define functions for convenience
(defn poly-canonical-coefficients [t]
  (eval-canonical t c))

(defn poly-horner-coefficients [t]
  (eval-horner t c))

[(poly-canonical-coefficients 0.0426236319)
 (poly-horner-coefficients 0.0426236319) ]
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's see how our new implementations perform against the fully expanded versions:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(rank
  1000
  :canonical #(poly-canonical 0.0426236319)
  :horner #(poly-horner 0.0426236319)
  :canonical-coefficients #(poly-canonical-coefficients 0.0426236319)
  :horner-coefficients #(poly-horner-coefficients 0.0426236319))
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, take some time to play around with the number of samples. I see results along these lines:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The manually-coded functions are effectively in a race condition for the baseline position.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;:horner-coefficients&lt;/code&gt; version is around 2-3X slower than the baseline.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;:canonical-coefficients&lt;/code&gt; version is around 5-6X or 15-20X slower than the baseline depending on which version you used (The &lt;code&gt;Math/pow&lt;/code&gt; version is faster).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It would take some more analysis to see exactly what makes the last version slower (The number of arithmetic operations, the number of functions called, etc.), but that's beyond the scope of this post. The main point is that the Horner evaluator is still pretty good, but not as fast as something hand-unrolled. At this point, if you had a large polynomial you were evaluating you might well prefer using &lt;code&gt;eval-horner&lt;/code&gt; to manually coding the equation.&lt;/p&gt;&lt;h2 id=&quot;enter_macros&quot;&gt;Enter Macros&lt;/h2&gt;&lt;p&gt;What if there was a way to both express a polynomial compactly and efficiently while also getting the performance of the manual expansion? Luckily for us, Clojure macros allow us to do just this.&lt;/p&gt;&lt;p&gt;Here are our macros and supporting eval function:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;Note that we need to define our own eval function so that we can evaluate our macro args. 
;This is NOT required if you are doing this exercise in Clojure as eval is already part of core.
;See http://blog.klipse.tech/clojurescript/2016/04/04/self-host-part-1.html for details.
(defn eval [exp]
  (:value (cljs/eval-str cljs.env/*compiler*
                  (str exp)
                  &quot;&quot;
                  {:eval cljs/js-eval :context :expr :ns 'poly.core$macros}
                  identity)))
      
(defmacro canonical-expand [terms]
  (let [t# (eval terms)]
    `(fn [~'t]
       (+ ~@(for [i (range (count t#)) :let [c (t# i)]]
              `(* ~c ~@(repeat i 't)))))))

(defmacro horner-expand [terms]
  (let [t# (rseq (eval terms))]
    `(fn [~'t]
     ~(reduce (fn [b a] `(+ ~a (* ~b ~'t))) t#))))

(defmacro defpoly [n terms]
  `(def n (horner-expand ~terms)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The expansion macros take a vector of coefficients and fully expand the equation into the desired form as an anonymous function. I evaluate the terms so that vectors of coefficients can be passed in from predefined vars or functions rather than inlined numerical vectors. The &lt;code&gt;defpoly&lt;/code&gt; macro is provided for convenience. You can see the macro expansions right here:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;Macro expansion of simply polynomial in canonical form
(macroexpand '(poly.core/canonical-expand [1 2 3]))
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;Macro expansion of simply polynomial in horner form
(macroexpand '(poly.core/horner-expand [1 2 3]))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can create functions using these macros:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(def poly-canonical-macro 
  (poly.core/canonical-expand [134.96340251 477198.8675605 0.0088553 1.4343E-5]))
  
(def poly-horner-macro 
  (poly.core/horner-expand [134.96340251 477198.8675605 0.0088553 1.4343E-5]))
  
[(poly-canonical-macro 0.0426236319)
 (poly-horner-macro 0.0426236319)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, let's see how our macro-generated functions perform compared to our previous results:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(rank
  1000
  :canonical #(poly-canonical 0.0426236319)
  :horner #(poly-horner 0.0426236319)
  :canonical-coefficients #(poly-canonical-coefficients 0.0426236319)
  :horner-coefficients #(poly-horner-coefficients 0.0426236319)
  :canonical-macro #(poly-canonical-macro 0.0426236319)
  :horner-macro #(poly-horner-macro 0.0426236319))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You should see effectively identical results between the original hand-written functions and the new macro versions, with the coefficient evaluation versions lagging behind as before. You've now got the best of both worlds: a concise way to express your polynomial that is also performant. &lt;/p&gt;&lt;h2 id=&quot;big_polynomials&quot;&gt;Big Polynomials&lt;/h2&gt;&lt;p&gt;Up to this point, we've established that hand-unrolling a polynomial is faster (not always by a lot) than writing an evaluator using higher-order functions (e.g. &lt;code&gt;eval-horner&lt;/code&gt;). We've also established that you can do the unroll automatically by writing a clever macro, achieving the best of both worlds. Until now, the theoretically slower canonical polynomial examples haven't really been much slower, if at all, than the Horner form.&lt;/p&gt;&lt;p&gt;However, what happens when large polynomials come into play? In the general case, is Horner form that much better than canonical form? A motivating example is the power series expansions for e&lt;sup&gt;x,&lt;/sup&gt; sin, cos, and other transcendental functions.&lt;/p&gt;&lt;p&gt;Consider the power series expansion for e&lt;sup&gt;x:&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;\(e ^x = 1 + x + \frac{x ^2}{2!} + \frac{x ^3}{3!} + \dotsb \)&lt;/p&gt;&lt;p&gt;For our exercise, we'll create a polynomial series with all coefficients in the power series that don't blow up (Non-infinite denominators).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(def e-coefficients 
  (-&amp;gt;&amp;gt; (iterate (fn [[i f]] [(inc i) (* i f)]) [1.0 1.0])
       (map second)
       (take-while #(js/isFinite %))
       (mapv #(/ 1.0 %))))
       
;Should see 171
(count e-coefficients) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, let's create two macro-expanded polynomials and see how they perform:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;;Uncomment this at your own peril!!!!!
;(defonce exp-canonical-macro (poly.core/canonical-expand e-coefficients))
  
(defonce exp-horner-macro (poly.core/horner-expand e-coefficients))
 
;This should produce e in both cases.
;[(exp-canonical-macro 1.0) (exp-horner-macro 1.0)]
 
#_(rank
  10
  :canonical-macro #(exp-canonical-macro 1.0)
  :horner-macro #(exp-horner-macro 1.0)
  :canonical-eval #(eval-canonical 1.0 e-coefficients)
  :horner-eval #(eval-horner 1.0 e-coefficients))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the interest of not hanging your browser, I've commented out the canonical expansion for this example. If you are patient, feel free to uncomment it and wait until it evaluates. Then, uncomment the ranker. if you are extra patient, up the samples to 100.&lt;/p&gt;&lt;p&gt;Here is what you should see after much waiting:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;:horner-macro&lt;/code&gt; should be your baseline value.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:horner-eval&lt;/code&gt; should have a similar order of magnitude performance as &lt;code&gt;horner-macro&lt;/code&gt;. I see values in the 2-8X range.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:canonical-macro&lt;/code&gt; should be next. I see values in the 9-30X range.&lt;/li&gt;&lt;li&gt;&lt;code&gt;:caninical-eval&lt;/code&gt; should be worst, by far. I see values in the hundreds.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The actual numeric values should be taken with a grain of salt given the inability to gather a large number of samples and the precision of the timing function, but the overall conclusion should be the same - Horner evaluation (in any form) is much faster than canonical evalution (in any form) for large polynomials.&lt;/p&gt;&lt;p&gt;Note that in a Clojure REPL this runs much faster and is probably a better environment for this kind of experimentation (The canonical macro for e-coefficients still takes a while, though). In fact, when I do this exercise in a REPL and use &lt;a href=&quot;https://github.com/ptaoussanis/tufte&quot;&gt;tufte&lt;/a&gt; for timing, I get these results:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/tufte-macros.jpg&quot; alt=&quot;alt text&quot; title=&quot;Polynomial comparisons&quot; /&gt;&lt;/p&gt;&lt;p&gt;Although the numbers are different, the overall rankings and qualitative results are the same.&lt;/p&gt;&lt;p&gt;So, to answer the questions posed at the beginning of the section - Yes, you should use Horner's method, especially with larger polynomials.&lt;/p&gt;&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;&lt;p&gt;In this exercise, I explained a couple of ways to evaluate polynomials as well as multiple ways of implementing those methods. Here are the high points:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Horner polynomial evaluation is more efficient than canonical evaluation. However, the Horner form can be a bit ugly to code.&lt;/li&gt;&lt;li&gt;Horner evaluation using a vector of coefficients and reduce is efficient and simple. However, for small polynomials there can be a noticeable difference in speed between using reduce vs. simply hand coding the Horner form.&lt;/li&gt;&lt;li&gt;The &lt;code&gt;horner-expand&lt;/code&gt; macro presented gives the best of both worlds - the performance of a manually-expanded function and the compactness and simplicity of a coefficients vector.&lt;/li&gt;&lt;li&gt;For large polynomials the differences in implementation, especially between Horner and canonical forms, can be dramatic.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;a_note_of_thanks&quot;&gt;A Note of Thanks&lt;/h3&gt;&lt;p&gt;When developing this post I was having some trouble getting my eval function working within the klipse environment. Mike Fikes, David Nolen, and others from the community were quick to help me get it working. I'd like to express my thanks to them and the Clojure community in general. We've got a great community that is always willing to help out with any problem or question, and I'm happy and proud to be a part of it.&lt;/p&gt;&lt;h3 id=&quot;footnote&quot;&gt;Footnote&lt;/h3&gt;&lt;p&gt;For this exercise, I've been using terms from the equation describing nutation (a perturbation of the Earth's rotation) due to the Moon. See &quot;Fundamentals of Astrodynamics and Applications&quot; by David Vallado if you want to learn more.&lt;/p&gt;
</description>
<pubDate>
Mon, 10 Jul 2017 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2017-06-19-clojure-rising/
</guid>
<link>
https://markbastian.github.io/posts-output/2017-06-19-clojure-rising/
</link>
<title>
Clojure Rising
</title>
<description>
 &lt;h1 id=&quot;still&amp;#95;here,&amp;#95;still&amp;#95;doing&amp;#95;clojure&quot;&gt;Still Here, Still Doing Clojure&lt;/h1&gt;&lt;p&gt;It's been a while since I've added to my blog over at &lt;a href='https://fn-code.blogspot.com'&gt;fn-code&lt;/a&gt;. If you were to speculate that this is because I am no longer a Clojurian, you would be very wrong. In fact, from my perspective Clojure adoption and usage is alive, well, and growing in both my own life and in the community.&lt;/p&gt;&lt;p&gt;As far as the lack of blogging goes, here's a summary of what's been going on with me:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;I changed jobs in late 2015 and moved from New Mexico to Idaho.&lt;/li&gt;&lt;li&gt;I've been actively evangelizing and promoting Clojure within my own company, to great effect. This takes a lot of time.&lt;/li&gt;&lt;li&gt;Other competing interests: Family, personal coding projects, learning IoT, reading books, playing games, sleeping, etc.&lt;/li&gt;&lt;li&gt;Google modified Drive to no longer serve up JavaScript libraries and other assets which made blogger a much less attractive blogging platform. Finding and implementing a &lt;i&gt;good&lt;/i&gt; workaround has been a time suck.&lt;/li&gt;&lt;li&gt;Blogging is hard. If you don't believe me, try to write an informative and interesting post. Then continue to do so on a regular basis.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So, despite the lack of blogging I've still been living the Clojure dream. My public presence has just been reduced due to competing interests for my time. A few weeks ago, though, there was a minor kerfuffle on some of the interwebs regarding the early demise of Clojure that made me think I should get back into the blogging scene. My audience probably  isn't huge, but I still wanted to let people know that in my world, at least, Clojure is not dead, but is very much on the rise.&lt;/p&gt;&lt;h1 id=&quot;clojure&amp;#95;rising&quot;&gt;Clojure Rising&lt;/h1&gt;&lt;p&gt;From where I sit, I am personally witnessing rising Clojure adoption and enthusiasm.&lt;/p&gt;&lt;p&gt;At my former employer, Sandia National Laboratories, my team has gone &quot;all in&quot; on Clojure. Here's a talk given at  Clojure/conj 2016 from a former co-worker, Jennifer Lewis, about her experiences:&lt;/p&gt;&lt;p&gt;&lt;iframe width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://www.youtube.com/embed/RB65-zYLNSY&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;&lt;p&gt;I don't stay in frequent contact with my Sandia colleagues, but when I do hear from them they are still going strong on  the Clojure front.&lt;/p&gt;&lt;p&gt;At my current employer, Clearwater Analytics, there is one team of 9 developers that are &quot;all in&quot; on Clojure as well as  a few others that work on smaller projects in Clojure. When I started out at Clearwater in September 2015 I was the only  hard core Clojure developer. A few others had dabbled in the language and really liked it but nobody was doing any full  time work in it. That's a substantial change in just over a year and a half. &lt;a href='https://clearwateranalytics-openhire.silkroad.com/epostings/index.cfm?fuseaction=app.jobinfo&amp;jobid=162&amp;source=ONLINE&amp;JobOwner=992285&amp;company_id=17178&amp;version=1&amp;byBusinessUnit=NULL&amp;bycountry=1&amp;bystate=1&amp;byRegion=US_ID&amp;bylocation=US&amp;keywords=&amp;byCat=36316&amp;proximityCountry=&amp;postalCode=&amp;radiusDistance=&amp;isKilometers=&amp;tosearch=yes&amp;city='&gt;We even have a full-time job posting exclusively for Clojure developers&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Beyond my own experiences, I see many companies that are doing really interesting work in Clojure as well. Companies  like Walmart Labs, LonoCloud, and ThreatGrid (to name a few - &lt;a href='https://clojure.org/community/success_stories'&gt;there are many others&lt;/a&gt;)  are doing really amazing work to solve challenging problems and the recurring theme is that Clojure is a major enabler. Teams that have adopted Clojure often report having the common experience of being more productive and having more fun  while doing it.&lt;/p&gt;&lt;p&gt;So, yes, I see a lot of opportunities in the Clojure landscape and I think things are only going to get better. Smart teams are continuing to see the Clojure ecosystem as a way to implement creative, cutting-edge solutions to problems much  faster than other technologies and they are having fun while doing it.&lt;/p&gt;&lt;h1 id=&quot;recommitting&amp;#95;to&amp;#95;the&amp;#95;blog&quot;&gt;Recommitting to the Blog&lt;/h1&gt;&lt;p&gt;Despite the rosy outlook from my perspective, I see that not everything is perfect in Clojure-land. We are still a  relatively small community that needs to work to foster growth and adoption. For my part, I am going to try to get back into providing regular blog content that is useful to the community. &lt;/p&gt;&lt;p&gt;A couple topics that I think would be of value are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Functional programming basics: Learning Clojure, functional programming, and new tooling (e.g. Emacs+CIDER) at the same time can be daunting. For many Clojure neophytes, this is the situation. I have some ideas for posts that  illustrate some of the basic concepts to help those trying to get into the FP paradigm while also learning Clojure.&lt;/li&gt;&lt;li&gt;Adoption tips and tricks: I have had the great opportunity of leading adoption of Clojure at two different organizations. This wasn't serendipitous. I'll blog on this and provide some advice to those of you who want to do Clojure  full time but aren't seeing a path to it.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I'll also continue to blog about topics of general interest regarding Clojure.&lt;/p&gt;&lt;h1 id=&quot;aside:&amp;#95;the&amp;#95;new&amp;#95;platform&quot;&gt;Aside: The New Platform&lt;/h1&gt;&lt;p&gt;After experiencing frustration with blogger I spent a bunch of time looking at alternatives. After some recent posts from the community about &lt;a href='http://cryogenweb.org'&gt;Cryogen&lt;/a&gt; I decided to give it a shot and all I can say is that it is awesome.  So, this is the new home for my blog. I've migrated all of my old posts over as well. I hope you come back soon.&lt;/p&gt;
</description>
<pubDate>
Mon, 19 Jun 2017 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2016-04-07-tetris/
</guid>
<link>
https://markbastian.github.io/posts-output/2016-04-07-tetris/
</link>
<title>
Another Tetris Clone in Clojure
</title>
<description>
 &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Recently I was looking at a problem involving extracting and transposing submatrices of data within a larger data grid. Somehow this got me thinking how easy it would be to rotate &lt;a href='https://en.wikipedia.org/wiki/Tetromino'&gt;tetrominos&lt;/a&gt; using Clojure. In case you are wondering, it is super easy:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn rotate-ccw &amp;#91;shape&amp;#93; 
  &amp;#40;apply mapv vector &amp;#40;map rseq shape&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn rotate-cw &amp;#91;shape&amp;#93; 
  &amp;#40;apply mapv &amp;#40;comp vec rseq vector&amp;#41; shape&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These two functions will rotate a tetromino counterclockwise and clockwise, respectively. No math required.&lt;/p&gt;&lt;p&gt;After doing this trivial exercise I soon found myself asking myself &quot;How fast can I code up Tetris in Clojure.&quot; It turns out that the answer is &quot;pretty fast.&quot; Let me first say that this is not a new idea. It has been done &lt;a href='http://timothypratley.blogspot.com/2015/07/you-should-be-using-figwheelreagent.html'&gt;here&lt;/a&gt; and &lt;a href='https://github.com/yogthos/clj-tetris'&gt;here&lt;/a&gt; as well. I still thought it would be fun, so here is my solution along with some insights.&lt;/p&gt;&lt;p&gt;Here's the game. Press the left and right arrow keys to translate, up and down arrows to rotate, and the space bar to make the the tetromino immediately fall into place.&lt;/p&gt;&lt;p&gt;&lt;div id=&quot;app&quot;&gt; &lt;script src=&quot;../../js/tetris.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;Read on to learn more about how the game was actually written.&lt;/p&gt;&lt;h2 id=&quot;data&amp;#95;first&amp;#95;design&quot;&gt;Data First Design&lt;/h2&gt;&lt;p&gt;As anyone who has seen my &lt;a href='https://www.youtube.com/watch?v=Tb823aqgX_0&quot;'&gt;Clojure/conj video&lt;/a&gt; or talked to me knows, I believe the best approach to coding a solution to a problem is to model the data literally rather than design an API to represent the data. Why model a domain when you can represent it directly instead? Clojure is made for this approach. This exercise is no different, as the first step is to model the shapes as maps of vector literals. Rather than making some sort of base &quot;Tetromino&quot; class and extending a bunch of methods and having some field that loads a bitmap or some such nonsense, I just did what you see here:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def shapes
  {:I &amp;#91;&amp;#91;0 0 0 0&amp;#93;
       &amp;#91;1 1 1 1&amp;#93;
       &amp;#91;0 0 0 0&amp;#93;
       &amp;#91;0 0 0 0&amp;#93;&amp;#93;
   :J &amp;#91;&amp;#91;0 0 0&amp;#93;
       &amp;#91;1 1 1&amp;#93;
       &amp;#91;0 0 1&amp;#93;&amp;#93;
   :L &amp;#91;&amp;#91;0 0 0&amp;#93;
       &amp;#91;1 1 1&amp;#93;
       &amp;#91;1 0 0&amp;#93;&amp;#93;
   :O &amp;#91;&amp;#91;1 1&amp;#93;
       &amp;#91;1 1&amp;#93;&amp;#93;
   :S &amp;#91;&amp;#91;0 0 0&amp;#93;
       &amp;#91;0 1 1&amp;#93;
       &amp;#91;1 1 0&amp;#93;&amp;#93;
   :T &amp;#91;&amp;#91;0 0 0&amp;#93;
       &amp;#91;1 1 1&amp;#93;
       &amp;#91;0 1 0&amp;#93;&amp;#93;
   :Z &amp;#91;&amp;#91;1 1 0&amp;#93;
       &amp;#91;0 1 1&amp;#93;
       &amp;#91;0 0 0&amp;#93;&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pretty cool, eh? You can look right at the shape entries and see the shapes as they are encoded in the data structures as 1s in a field of 0s. Of course, the current shape will be translating and rotating during the game, so I must keep track of that. I also want to track a few other game values, such as the current score, high score, values to keep track of when a tetromino falls, as well as the cells that are currently locked into place.&lt;/p&gt;&lt;p&gt;This can all be captured in a single function that generates an initial state representing a complete value for the game.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn initial-state &amp;#91;&amp;#93;
  {:frame 0
   :speed 50
   :score 0
   :high-score 0
   :locked #{}
   :shape-pos &amp;#91;&amp;#40;rand-int 7&amp;#41; 0&amp;#93;
   :shape &amp;#40;&amp;#40;rand-nth &amp;#40;keys shapes&amp;#41;&amp;#41; shapes&amp;#41;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The data structure above completely represents all of the values I need to keep track of for my entire game. The most interesting entries are locked, shape-pos, and shape. locked is a set of coordinates in the board that contain locked cells. shape-pos is the upper left hand coordinate of the current tetramino. shape is the current falling tetramino shape. Note that I do not keep track of rotation. I just rotate the piece in place.&lt;/p&gt;&lt;p&gt;At this point, all that remains is filling in some functions and methods around this data for user interaction, game rules, and rendering. Here are some of the details.&lt;/p&gt;&lt;h3 id=&quot;implicit&amp;#95;board&amp;#95;representation&quot;&gt;Implicit Board Representation&lt;/h3&gt;&lt;p&gt;Rather than taking the usual approach of creating an MxN grid, I implicitly represent the board by using rules for boundaries (nothing can be outside of the board dimensions) and a hash set to represent the blocks currently &quot;locked in&quot; to the board. This definition looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn valid? &amp;#91;{:keys &amp;#91;locked&amp;#93; :as state}&amp;#93;
  &amp;#40;every? &amp;#40;fn &amp;#91;&amp;#91;x y :as c&amp;#93;&amp;#93;
            &amp;#40;and &amp;#40;&amp;#40;complement locked&amp;#41; c&amp;#41; 
                 &amp;#40;&amp;lt;= 0 x 9&amp;#41; &amp;#40;&amp;lt; y 22&amp;#41;&amp;#41;&amp;#41;
          &amp;#40;shape-coords state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Basically, for every coordinate in the current falling shape (The shape-coords function) I check to see if it is within the game's x-y grid and if it is not contained in the locked set of cells.&lt;/p&gt;&lt;p&gt;Speaking of computing the coordinates of the current shape, this is something I'll do a lot, so here's a handy function to do it:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn shape-coords &amp;#91;{:keys &amp;#91;shape-pos shape&amp;#93;}&amp;#93;
  &amp;#40;let &amp;#91;d &amp;#40;count shape&amp;#41;&amp;#93;
    &amp;#40;for &amp;#91;i &amp;#40;range d&amp;#41; j &amp;#40;range d&amp;#41; 
          :when &amp;#40;= 1 &amp;#40;get-in shape &amp;#91;i j&amp;#93;&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;mapv + &amp;#91;i j&amp;#93; shape-pos&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function destructures the current shape position and shape cells from the game and returns the coordinates of the 4 cells in the shape (the 1s).&lt;/p&gt;&lt;h3 id=&quot;moves&quot;&gt;Moves&lt;/h3&gt;&lt;p&gt;Given the above representations, the game reduces down to making valid tetromino moves within the board. There are two scenarios for moving a tetromino:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The user moves it (This does not include the user making the tetromino fall faster). A user can translate or rotate a tetromino. The only thing the game must do when a user performs a translation or rotation is see if the new piece is in a valid location. If it is you accept the new value, if not you just reject the move.&lt;/li&gt;&lt;li&gt;It is falling. When a tetromino falls (either over time or by a user forcing it to fall faster) there is only one thing to consider: Is the new position overlapping the set of locked blocks? If so, we do not allow the tetromino to fall, but instead add the former grid positions of the tetromino to the locked block set.A key point here is that rather than allowing invalid operations to be performed and throwing exceptions or other similar mechanisms, this program simply rejects any invalid operations and always maintains a valid value for the current state.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Here are the functions for piece translation and rotation:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn x-shift &amp;#91;state f&amp;#93;
  &amp;#40;let &amp;#91;shifted &amp;#40;update-in state &amp;#91;:shape-pos 0&amp;#93; f&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;valid? shifted&amp;#41; shifted state&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn rotate &amp;#91;state f&amp;#93;
  &amp;#40;let &amp;#91;shifted &amp;#40;update state :shape f&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;valid? shifted&amp;#41; shifted state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above code x-shift means &quot;translate shift&quot; and f is a function to be applied to the shape position (either inc or dec for right or left translation, respectively). rotate takes on of the two rotation functions I defined at the beginning of this post.&lt;/p&gt;&lt;p&gt;For falling, the logic is a bit more complex:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn fall &amp;#91;state&amp;#93;
  &amp;#40;let &amp;#91;shifted &amp;#40;update-in state &amp;#91;:shape-pos 1&amp;#93; inc&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;valid? shifted&amp;#41;
      shifted
      &amp;#40;let &amp;#91;locked-coords &amp;#40;shape-coords state&amp;#41;&amp;#93;
        &amp;#40;-&amp;gt; state
            &amp;#40;update :locked into locked-coords&amp;#41;
            &amp;#40;score 1&amp;#41;
            &amp;#40;#&amp;#40;reduce clear-row % &amp;#40;map second locked-coords&amp;#41;&amp;#41;&amp;#41;
            &amp;#40;into { :shape &amp;#40;&amp;#40;rand-nth &amp;#40;keys shapes&amp;#41;&amp;#41; shapes&amp;#41;
                   :shape-pos &amp;#91;&amp;#40;rand-int 7&amp;#41; 0&amp;#93;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, we first do a simple shift. If it is valid, we are done. If it isn't valid that means we've either moved off the bottom of the board or intersected with existing locked pieces. Either way, we lock the unshifted cells into the board and then check to see if rows need clearing. Finally, we add in a new random shape at the top of the board. I also give the player a point when a cell locks.&lt;/p&gt;&lt;p&gt;The player can also execute a fast drop in which they have a piece prepositioned and want it to immediately lock so they can get the next piece. This is as simple as:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn fast-drop &amp;#91;{:keys &amp;#91;locked&amp;#93; :as state}&amp;#93;
  &amp;#40;some #&amp;#40;when &amp;#40;not= locked &amp;#40;:locked %&amp;#41;&amp;#41; %&amp;#41; 
        &amp;#40;iterate fall state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function iterates over the current state with the fall function until the set of locked set of cells change. This will occur when the falling piece can no longer fall.&lt;/p&gt;&lt;h3 id=&quot;clearing&amp;#95;rows&quot;&gt;Clearing Rows&lt;/h3&gt;&lt;p&gt;Clearing a row occurs when all every cell in a row is locked. When this occurs, state is threaded such that 10 points are awarded, the speed is decreased (more on this in the next section), and cells are kept, removed, or shifted depending on their relation to the row to be removed.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn clear-row &amp;#91;{:keys &amp;#91;locked&amp;#93; :as state} row&amp;#93;
  &amp;#40;if &amp;#40;every? locked &amp;#40;for &amp;#91;i &amp;#40;range 10&amp;#41;&amp;#93; &amp;#91;i row&amp;#93;&amp;#41;&amp;#41;
    &amp;#40;-&amp;gt; state
        &amp;#40;score 10&amp;#41;
        &amp;#40;update :speed dec&amp;#41;
        &amp;#40;assoc :locked
               &amp;#40;set &amp;#40;for &amp;#91;&amp;#91;i j&amp;#93; locked :when &amp;#40;not= j row&amp;#41;&amp;#93;
                      &amp;#40;if &amp;#40;&amp;lt; j row&amp;#41; &amp;#91;i &amp;#40;inc j&amp;#41;&amp;#93; &amp;#91;i j&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    state&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;bringing&amp;#95;it&amp;#95;all&amp;#95;together&quot;&gt;Bringing It All Together&lt;/h3&gt;&lt;p&gt;The final function needed is a game-step function that is called by the user interface layer for each game time step. Here's the function:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn game-step &amp;#91;{:keys &amp;#91;frame locked speed&amp;#93; :as state}&amp;#93;
  &amp;#40;cond-&amp;gt; &amp;#40;update state :frame inc&amp;#41;
          &amp;#40;zero? &amp;#40;mod frame &amp;#40;max speed 1&amp;#41;&amp;#41;&amp;#41;
          fall
          &amp;#40;some zero? &amp;#40;map second locked&amp;#41;&amp;#41;
          &amp;#40;into &amp;#40;dissoc &amp;#40;initial-state&amp;#41; :high-score&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function updates the frame at each time step then does some conditional threading at the new game step. First, if the frame modded with the current speed is zero, the tetromino falls. So, speed in this game is really a misnomer. Lower speed makes the tetromino fall more frequently. Finally, if any y coordinate in the locked cells is at 0 (I am using screen coordinates, so 0 is at the top of the screen going down) we reset the game but maintain the current high score.&lt;/p&gt;&lt;p&gt;A Complete Rule Set and a UI All of the above code in a single namespace completely defines the game engine. All that is needed is a user interface to display the current value and take user input. I won't go into the details of the UI in this post, but might later. However, here are a couple of high level details about the UI: I actually did 2 interfaces - one using Quil and one using Reagent. The one embedded here is the Reagent version. The Quil UI compiles to both Java and JavaScript where the Reagent version just compiles to JavaScript. The rules are written as cljc files so cross compile without issue. Either UI is only about 50-70 lines of code, so are pretty minimal.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Once again, Clojure's ability to let me model a domain directly as data and then write functions to manipulate those domain values has yielded a simple and concise solution to a problem. I find it pretty amazing that I can write an entire game, including UI, in about 150 lines of code. Not only is the solution brief, but I think the simple function names and full-state representation of values makes the code pretty readable. Despite being a simple case in this post, I've found this technique to be quite useful in domains of any size or complexity. However, a key requirement for this approach is a language that has full support for modeling the domain as data. Clojure is an excellent fit as it was designed to be data first from inception.&lt;/p&gt;&lt;p&gt;The complete source for this project can be cloned &lt;a href='https://github.com/markbastian/tetris'&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Thu, 07 Apr 2016 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-12-01-gettingstarted/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-12-01-gettingstarted/
</link>
<title>
Clojure: Getting Started
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Often people will ask me how to get started in Clojure. Most often they have a Java background, but sometimes they are  coming from C++, Python, or some other popular language. Either way, I rehash the same story and spent a bunch of time  finding and consolidating the same links as the last time someone asked me this question.    &lt;/p&gt;&lt;p&gt;This post is meant to be my simple, consolidated answer to &quot;How do I get started with Clojure?&quot;    &lt;/p&gt;&lt;p&gt;Here's how...    &lt;/p&gt;&lt;h3 id=&quot;pick&amp;#95;a&amp;#95;project&quot;&gt;Pick a Project&lt;/h3&gt;&lt;p&gt;Before you do anything else, you really need to pick some simple project you will do in Clojure. In my experience,  attempting to learn something without some concurrent hands-on experience isn't particularly effective. My first  non-trivial (i.e. (prn &quot;Hello World)) application was an implementation of the board game  &lt;a href='https://boardgamegeek.com/boardgame/826/cartagena'&gt;Cartagena&lt;/a&gt; that I talked about  at Clojure/conj. You can watch it right here:&lt;/p&gt;&lt;p&gt;&lt;iframe width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://www.youtube.com/embed/Tb823aqgX_0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;&lt;p&gt;I suggest an application that has some state, whether it be a desktop application or single page web app  (using ClojureScript). That way you can use atoms and understand how Clojure separates the concerns of state  (atoms, agents, or refs), value (data), and transition (functions). I think board games make excellent projects,  but then again I really like board games. You could do just about anything.&lt;/p&gt;&lt;h3 id=&quot;watch&amp;#95;&amp;&amp;#95;read&quot;&gt;Watch &amp; Read&lt;/h3&gt;&lt;p&gt;Here are a few links I recommend to everyone, not in any particular order. They are all excellent.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://www.braveclojure.com/'&gt;Clojure for the Brave and True&lt;/a&gt;: Daniel Higginbotham's truly awesome book/onlinelearning series on learning Clojure from the ground up. &lt;a href='https://www.amazon.com/Clojure-Brave-True-Ultimate-Programmer/dp/1593275919/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=sl1&amp;tag=braveclojure-20&amp;linkId=e3c6527befc02cce112deb5b8fbc3774'&gt;Buy it here&lt;/a&gt;. This is my #1 recommended getting started resource.&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojure.org/reference/evaluation'&gt;Clojure Evaluation&lt;/a&gt;: The single most important documentation page on Clojure in the entire universe. Once you understand this page you pretty much know the entire language (not the APIs). Yes, Clojure is this simple.&lt;/li&gt;&lt;li&gt;&lt;a href='https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm/'&gt;Clojure - Functional Programming for the JVM&lt;/a&gt;: Mark Volkmann's extremely direct and to the point single web page description of Clojure.&lt;/li&gt;&lt;li&gt;&lt;a href='https://changelog.com/posts/rich-hickeys-greatest-hits'&gt;Rich Hickey's Greatest Hits&lt;/a&gt;: Most of these are more philosophical than tutorial in nature, but they give you great insights into the genius behind Clojure. Key concepts such as value, state, identity, etc. are described in these videos. My favorites:&lt;ul&gt;&lt;li&gt;Are We There Yet?&lt;/li&gt;&lt;li&gt;Simple Made Easy&lt;/li&gt;&lt;li&gt;The Value of Values&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;in&amp;#95;conclusion&quot;&gt;In Conclusion&lt;/h2&gt;&lt;p&gt;Hopefully the above tips and links will give you a little help if you are considering Clojure and want to know where to  start. Either way, I'll have something to point to next time someone asks me.&lt;/p&gt;
</description>
<pubDate>
Tue, 01 Dec 2015 00:00:00 -0700
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-10-26-concerns/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-10-26-concerns/
</link>
<title>
My Concern with Concerns
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;In the Computer Science world we often talk about the value of Separation of Concerns (SoC). &lt;a href='https://en.wikipedia.org/wiki/Separation_of_concerns'&gt;This Wikipedia article&lt;/a&gt; on the subject says that well-separated code is more modular, maintainable, and reusable. The basic idea is that we separate our code into components by their roles so that those pieces can be used and developed independently as well as assembled into a greater whole.&lt;/p&gt;&lt;p&gt;However, I am concerned with the traditional treatment of concerns. We often look at concerns as a breakdown of our application into various interconnected pieces, or objects. For example, you might have a game program with a rendering system, an input system, a physics system, and so on. A spreadsheet application might have concerns regarding computations, persistence, and input. At a high level, and borrowing from the Wikipedia article, you might have concerns for things like business logic, persistence, data access, and presentation.&lt;/p&gt;&lt;p&gt;Two major flaws with the typical treatment of SoC as described above stand out to me:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;In many of these systems the various parts require knowing about each other to the degree that if you use one, you must also use the others. This leads to complected, interconnected systems. Rich Hickey talks all about it &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;here&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;We have jumped past some core fundamental concerns of how we think about computing and moved straight to high level constructs (usually objects, layers, or systems). This is what I want to talk about.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;These are the three low level concerns I am concerned about:&lt;/p&gt;&lt;h3 id=&quot;representation:&amp;#95;how&amp;#95;do&amp;#95;you&amp;#95;describe&amp;#95;the&amp;#95;world?&quot;&gt;Representation: How do you describe the world?&lt;/h3&gt;&lt;p&gt;The first concern to consider is how you represent your world. In a traditional object oriented approach, the simple solution is objects with their corresponding fields. Even in many functional or mostly functional languages like Scala you will use value types to represent your world. Consider the following three ways to represent a person:&lt;/p&gt;&lt;h4 id=&quot;java&quot;&gt;Java&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package concerns;

public class Person {
    private String name;
    private int age;
    private double weight;

    public Person&amp;#40;&amp;#41; {
    }

    public Person&amp;#40;String name, int age, double weight&amp;#41; {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }

    public String getName&amp;#40;&amp;#41; {
        return name;
    }

    public void setName&amp;#40;String name&amp;#41; {
        this.name = name;
    }

    public int getAge&amp;#40;&amp;#41; {
        return age;
    }

    public void setAge&amp;#40;int age&amp;#41; {
        this.age = age;
    }

    public double getWeight&amp;#40;&amp;#41; {
        return weight;
    }

    public void setWeight&amp;#40;double weight&amp;#41; {
        this.weight = weight;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;scala&quot;&gt;Scala&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;case class Person&amp;#40;name : String, age : Int, weight : Double&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;clojure&quot;&gt;Clojure&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{ :name &amp;quot;Zaphod&amp;quot; :age 21 :weight 160.0 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clojure is unique in that practitioners generally represents the world as simple data structures. Other languages would have you define a class for your data (Often in a painfully verbose way, I might add), but Clojure simply views everything as data. You can use gen-class or defrecord, but you generally don't unless you are shooting for Java interop or feel the need for a defined structural type.&lt;/p&gt;&lt;p&gt;Clojure is relatively unique in that it allows you to flexibly represent anything using a small number of primitives and heterogeneous, nested data structures. You have a single, uniform approach to representing anything as data, whether it be simple or extremely complicated.&lt;/p&gt;&lt;p&gt;Classes, on the other hand, require a new class for any level of modification of representation. A person with height would need to extend a base Person (e.g. PersonWithHeight extends Person). This leads to elaborate type hierarchies and an explosion of representations. Classes also fail disastrously when dealing with temporal changes. Suppose you want to transition from a Caterpillar to a Butterfly or from an Employee to a Manger (You got a promotion. Congratulations!). How do you handle these? Do you pass roles around? Does that work in the caterpillar to butterfly case? Is there a GoF anti-pattern for that?&lt;/p&gt;&lt;p&gt;This is not to say classes do not have their place. If your representation is well-known at design time a class can be an excellent fit for your problem. For example, a 3D mathematical vector is very well defined with fields along 3 axes. However, using classes to represent things with a wide variety of potential fields or that transition over time can be a disaster.&lt;/p&gt;&lt;p&gt;Clojure's simple approach to the concern of representation is wonderful, but we are here to discuss the separation of concerns, so let's talk about another concern that we need to keep separate...&lt;/p&gt;&lt;h3 id=&quot;behavior:&amp;#95;how&amp;#95;do&amp;#95;you&amp;#95;modify&amp;#95;or&amp;#95;use&amp;#95;your&amp;#95;representation&amp;#95;of&amp;#95;the&amp;#95;world?&quot;&gt;Behavior: How do you modify or use your representation of the world?&lt;/h3&gt;&lt;p&gt;The next concern is how you modify the representation of your world, or how you transition from one representation to another. Tied to this is how you do things with your objects, even if you don't modify them. In OOP this is done by class methods that operate on themselves or objects they are familiar with. This seems natural, as most verbs tend to operate on some noun. For example, a rename method clearly must rename something. What is that thing? For an object, it logically is the thing rename is attached to.&lt;/p&gt;&lt;p&gt;However, this complects the concerns of representation and behavior.&lt;/p&gt;&lt;p&gt;Consider the trivial situation of managing named objects. What if I want to rename a person, car, dog, or file? In OOP, I need to add a method to every object (e.g. setName or rename) that is nameable. You might argue for a common base class (e.g. AbstractRenameable), but now everything must extend this class, and you don't want to waste your one-shot inheritance on something so trivial. Instead, maybe you implement IName and proxy a DefaultName. In any event, you are complected up the wazoo for something so simple as the ability to rename an object. And you have to do this every time, for every field on every object.&lt;/p&gt;&lt;p&gt;Wouldn't it be better to have some independent function that renames every structurally similar piece of data? I can do this trivially in Clojure like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn rename&amp;#91;o name&amp;#93;&amp;#40;assoc o :name name&amp;#41;&amp;#41;

&amp;#40;pp/pprint
  &amp;#40;rename
    { :name &amp;quot;Zaphod Beeblebrox&amp;quot;
     :age 21
     :weight 160.0 }
    &amp;quot;Ford Prefect&amp;quot;&amp;#41;&amp;#41;

&amp;#40;pp/pprint
  &amp;#40;rename
    { :type :spaceship
     :name &amp;quot;Heart of Gold&amp;quot;
     :color :red }
    &amp;quot;Millenium Falcon&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This produces the following output:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:name &amp;quot;Ford Prefect&amp;quot;, :age 21, :weight 160.0}
{:type :spaceship, :name &amp;quot;Millenium Falcon&amp;quot;, :color :red}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One function that works on any structurally similar object. Compare this to putting a rename method on every named object in existence. This is what I call a separation of concerns.&lt;/p&gt;&lt;p&gt;Let's look at a slightly less trivial example. Suppose you are writing a sprite-based game and have a variety of scene elements that you want to render. Each element must have information for its location and the image to be drawn. Let's look at how you might render a sprite-based image in our three languages using Java 2D:&lt;/p&gt;&lt;h4 id=&quot;java&quot;&gt;Java&lt;/h4&gt;&lt;p&gt;Here is what you would add to the above class:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public void render&amp;#40;Graphics2D g&amp;#41;{
    g.drawImage&amp;#40;getImage&amp;#40;&amp;#41;, getX&amp;#40;&amp;#41;, getY&amp;#40;&amp;#41;, null&amp;#41;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This, of course, assumes you have also added fields and methods to manage the image and the item's location. You've now fundamentally intertwined your class with the Java 2D library, some AWT classes for handing images, and whatever else you've done to make this work.&lt;/p&gt;&lt;h4 id=&quot;scala&quot;&gt;Scala&lt;/h4&gt;&lt;p&gt;Scala suffers from the same problem as Java because it still complects the concerns of representation and behavior. In Scala's defense, it does have duck typing, structural typing, and traits that allow you to do a variety of things to repeat yourself a lot less. It's a better situation, but it does add complexity to your solution and you have to go to a lot of effort to separate your behavior from your representation.&lt;/p&gt;&lt;h4 id=&quot;clojure&quot;&gt;Clojure&lt;/h4&gt;&lt;p&gt;Clojure completely separates the concerns of representation and behavior by using pure data structures to represent data and functions to represent behavior. The only required interface is correct structural inputs to functions.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn render &amp;#91;g {:keys &amp;#91;image x y&amp;#93;}&amp;#93;
  &amp;#40;.drawImage g image x y nil&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example, any data conforming to the required interface (Having entries for the :image, :x, and :y keys) can be rendered. The data has no knowledge of Graphics2D and is only loosely coupled to AWT by having a field entry referencing an image. This data can be removed from the map entirely if not needed as opposed to an object which would have a null field that still references a foreign API. &lt;/p&gt;&lt;p&gt;We're now double-complected in OOP-land and have complete separation with Clojure. Let's throw another concern into the mix...&lt;/p&gt;&lt;h3 id=&quot;management:&amp;#95;how&amp;#95;do&amp;#95;you&amp;#95;keep&amp;#95;track&amp;#95;of&amp;#95;the&amp;#95;current&amp;#95;state&amp;#95;of&amp;#95;the&amp;#95;world?&quot;&gt;Management: How do you keep track of the current state of the world?&lt;/h3&gt;&lt;p&gt;Separate from the idea of how you represent and act in your world is how you keep track of your current (and perhaps historical) view of the world. This includes not just a handle to the current value of the world, but a mechanism for watching for changes and responding accordingly.&lt;/p&gt;&lt;p&gt;In Java this is accomplished via a fully implemented Java Bean, with getters, setters, property change support, property change listeners, and so on. Your bean class will have a mechanism to wire up things that listen for changes and changes are fired when change occurs. Again, we've further tied another concern to the object. We're now complected x3.&lt;/p&gt;&lt;p&gt;Scala doesn't address this concern directly, but you've got options. You can create Java Beans in Scala, but beans are an ugly, complicated mess that should be avoided if possible. You can use the Akka library, but in my experience Akka is too heavyweight and complicated for most problems.&lt;/p&gt;&lt;p&gt;Clojure, on the other hand, has atoms, agents, and refs. These concurrency primitives are designed exactly for the concern of state management. These 3 items each hold a value as their current state and have methods for performing safe modification synchronously, asynchronously, uncoordinated, or coordinated, depending on which primitive you need. All have the same API for dereferencing, watching for changes, and validating state. These primitives completely separate the concern of state management from the other concerns described in this post. You can read more about these primitives &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;One really great thing about Clojure concurrency primitives is that they are easy to use from any other JVM language, so you can leverage them in your Java or Scala projects to separate this concern if desired.&lt;/p&gt;&lt;h2 id=&quot;summary&amp;#95;and&amp;#95;conclusions&quot;&gt;Summary and Conclusions&lt;/h2&gt;&lt;p&gt;The following table summarizes what I have discussed in this post.&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Concern&lt;/th&gt;&lt;th&gt;OOP&lt;/th&gt;&lt;th&gt;FP&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;State&lt;/td&gt;&lt;td&gt;Object Fields&lt;/td&gt;&lt;td&gt;Values/Data&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Behavior&lt;/td&gt;&lt;td&gt;Object Methods&lt;/td&gt;&lt;td&gt;Functions&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Management&lt;/td&gt;&lt;td&gt;Object References&lt;/td&gt;&lt;td&gt;Concurrency Primitives&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Separation Level&lt;/td&gt;&lt;td&gt;Complected&lt;/td&gt;&lt;td&gt;Separated&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;The key takeaway is that objects fundamentally complect all concerns by their very nature. Clojure's separation of data, functions, and state management allow for a clean separation of these concerns as part of the language design. So, rather than beginning to design the world as objects, layers, and systems start with data, functions, and state. The former solution automatically puts you on the road to complexity while the latter allows you to keep your concerns separated all the way down.&lt;/p&gt;
</description>
<pubDate>
Mon, 26 Oct 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-09-24-state-mgmt/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-09-24-state-mgmt/
</link>
<title>
Clojure State Management by Example
</title>
<description>
 &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt; One of my favorite features of Clojure is the way changes in application state are handled. In Clojure we separate the concerns of our data (which is stored as values) and the management of how that data might change over time. Contrast this to most other languages that have mutable state tied to their object model at some level.  &lt;/p&gt;&lt;p&gt; There are four state management primitives. Here's a very simple example of each and how they behave.  &lt;/p&gt;&lt;h3 id=&quot;vars&quot;&gt;Vars&lt;/h3&gt;&lt;p&gt; Vars are what you get when you use def. def simply defines a value. If you declare the def'd value as dynamic, you can rebind it on a per-thread basis. Meaning, within your current scope you can rebind the value of the previously def'd value. Here's the example:  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def &amp;#94;:dynamic &amp;#42;a&amp;#42; 0&amp;#41; ;Note the &amp;#42;earmuff&amp;#42;
&amp;#40;def &amp;#94;:dynamic &amp;#42;b&amp;#42; 1&amp;#41; ;Clojure uses them for things mean to be rebound

&amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;original&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;

&amp;#40;future
  &amp;#40;binding &amp;#91;&amp;#42;a&amp;#42; 1 &amp;#42;b&amp;#42; 0&amp;#93;
    &amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;rebinding&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;
    &amp;#40;binding &amp;#91;&amp;#42;a&amp;#42; 11 &amp;#42;b&amp;#42; 45&amp;#93;
      &amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;another binding&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;exiting scope&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;&amp;#41;
  &amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;exiting scope&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;prn &amp;#40;str &amp;quot;&amp;#40;original ns value&amp;#41; a, b = &amp;quot; &amp;#42;a&amp;#42; &amp;quot;,&amp;quot; &amp;#42;b&amp;#42;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above produces this output:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;quot;&amp;#40;original&amp;#41; a, b = 0,1&amp;quot;
&amp;quot;&amp;#40;rebinding&amp;#41; a, b = 1,0&amp;quot;
&amp;quot;&amp;#40;original ns value&amp;#41; a, b = 0,1&amp;quot;
&amp;quot;&amp;#40;another binding&amp;#41; a, b = 11,45&amp;quot;
&amp;quot;&amp;#40;exiting scope&amp;#41; a, b = 1,0&amp;quot;
&amp;quot;&amp;#40;exiting scope&amp;#41; a, b = 0,1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, every time I rebind a and b in a new form, the old value are replaced within that scope. As soon as the form is exited, we are back to the previous binding. Finally, you can see that the last prn statement that prints the original binding value is unaffected by the future since the future is in a different thread. I don't find vars particularly useful or interesting, but for completeness's sake, there you have it. Our next three concurrency primitives are much more interesting.&lt;/p&gt;&lt;h3 id=&quot;atoms&quot;&gt;Atoms&lt;/h3&gt;&lt;p&gt;Atoms provide synchronous, uncoordinated state management. These are the workhorse of Clojure state management. Here's how it works using a simple example that updates two atoms and dumps out their results. A built-in delay is added to each update for illustration's sake.  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def a &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;def b &amp;#40;atom 1&amp;#41;&amp;#41;

&amp;#40;defn slow &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 300&amp;#41; f&amp;#41;
&amp;#40;defn slower &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 400&amp;#41; f&amp;#41;

&amp;#40;future
  &amp;#40;do
    &amp;#40;swap! a &amp;#40;comp slow inc&amp;#41;&amp;#41;
    &amp;#40;swap! b &amp;#40;comp slower dec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;future
  &amp;#40;loop &amp;#91;i 10&amp;#93;
    &amp;#40;when &amp;#40;pos? i&amp;#41;
      &amp;#40;do
        &amp;#40;prn &amp;#40;str &amp;quot;a, b = &amp;quot; @a &amp;quot;,&amp;quot; @b&amp;#41;&amp;#41;
        &amp;#40;Thread/sleep 100&amp;#41;
        &amp;#40;recur &amp;#40;dec i&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Output:  &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt; &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 1,1&amp;quot;
 &amp;quot;a, b = 1,1&amp;quot;
 &amp;quot;a, b = 1,1&amp;quot;
 &amp;quot;a, b = 1,1&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The above output illustrates that atoms are synchronous since it took 300ms for slow to execute on a and an additional 400ms for slower to execute on b. Also, the functions are uncoordinated - There is a time when slow has completed its work and slower has not. There is no connection between the two swap! operations.&lt;/p&gt;&lt;h3 id=&quot;refs&quot;&gt;Refs&lt;/h3&gt;&lt;p&gt;Refs provide synchronous, coordinated state management. Use a ref when you need a transaction to be performed correctly. For example, you could use Refs to track funds in a bank account. To transfer funds from one Ref'd account to another, put the transaction in a synchronized ref block. The following example is identical to the above, except that now we are altering a and b in a synchronized code block.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def a &amp;#40;ref 0&amp;#41;&amp;#41;
&amp;#40;def b &amp;#40;ref 1&amp;#41;&amp;#41;

&amp;#40;defn slow &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 300&amp;#41; f&amp;#41;
&amp;#40;defn slower &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 400&amp;#41; f&amp;#41;

&amp;#40;future
  &amp;#40;dosync
    &amp;#40;alter a &amp;#40;comp slow inc&amp;#41;&amp;#41;
    &amp;#40;alter b &amp;#40;comp slower dec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;future
  &amp;#40;loop &amp;#91;i 10&amp;#93;
    &amp;#40;when &amp;#40;pos? i&amp;#41;
      &amp;#40;do
        &amp;#40;prn &amp;#40;str &amp;quot;a, b = &amp;quot; @a &amp;quot;,&amp;quot; @b&amp;#41;&amp;#41;
        &amp;#40;Thread/sleep 100&amp;#41;
        &amp;#40;recur &amp;#40;dec i&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Output:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt; &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Unlike the previous example, no change occurred in a or b until both the slow and slower functions were applied to a and b. Since the operations were synchronous, it took the entire compute time of both functions to pass before both a and be were concurrently updated.&lt;/p&gt;&lt;h3 id=&quot;agents&quot;&gt;Agents&lt;/h3&gt;&lt;p&gt;Agents provide asynchronous, uncoordinated state management. If you want reactive behavior, use agents. As before, we are using the same example to illustrate agent behavior.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def a &amp;#40;agent 0&amp;#41;&amp;#41;
&amp;#40;def b &amp;#40;agent 1&amp;#41;&amp;#41;

&amp;#40;defn slow &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 300&amp;#41; f&amp;#41;
&amp;#40;defn slower &amp;#91;f&amp;#93; &amp;#40;Thread/sleep 400&amp;#41; f&amp;#41;

&amp;#40;future
  &amp;#40;do
    &amp;#40;send a &amp;#40;comp slow inc&amp;#41;&amp;#41;
    &amp;#40;send b &amp;#40;comp slower dec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;future
  &amp;#40;loop &amp;#91;i 10&amp;#93;
    &amp;#40;when &amp;#40;pos? i&amp;#41;
      &amp;#40;do
        &amp;#40;prn &amp;#40;str &amp;quot;a, b = &amp;quot; @a &amp;quot;,&amp;quot; @b&amp;#41;&amp;#41;
        &amp;#40;Thread/sleep 100&amp;#41;
        &amp;#40;recur &amp;#40;dec i&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Output:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt; &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 0,1&amp;quot;
 &amp;quot;a, b = 1,1&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
 &amp;quot;a, b = 1,0&amp;quot;
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this case, we see that both slow and slower executed concurrently, since a was updated after 300ms and b was updated only 100ms later.&lt;/p&gt;&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;&lt;p&gt;Clojure's concurrency primitives are very easy to use and make it simple to manage program state. However, it is important to know when to use which. Hopefully this simple set of examples will give you a clear idea as to the behaviors of each so that you'll know when to use them.&lt;/p&gt;
</description>
<pubDate>
Thu, 24 Sep 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-08-25-snake/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-08-25-snake/
</link>
<title>
A Clojure Snake Game
</title>
<description>
 &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;I recently decided to write a Snake game in Clojure as a small project. In the game you have a snake that grows as it consumes food. The goal of the game is to make the snake as long as possible without self-intersecting. I got the idea to do it on a Saturday morning and by that night I was done. Most of the coding was done in the evening since I was doing family activities all day. All told, this was probably a 3 hour project. The entire program is 75 lines of code. That's awesome! This includes both the JVM and JavaScript targets via Clojure and ClojureScript. Here's the game:&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas height=&quot;400&quot; id=&quot;snake-canvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;../../js/snake.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;snake.core.launch_app(document.getElementById(&quot;snake-canvas&quot;), 400, 400);&lt;/script&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;Here's how you play:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Use your arrow keys or w, a, s, d to change the snake's direction. Note that you probably will need to click on the canvas first to gain focus.&lt;/li&gt;&lt;li&gt;When the snake hits a green &quot;food&quot; pill it grows one unit longer.&lt;/li&gt;&lt;li&gt;When the snake intersects itself it resets to its original length.Your score is the length of your snake.&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;the&amp;#95;program&quot;&gt;The Program&lt;/h2&gt;&lt;p&gt;Here's the program. Read past it for my observations and comments.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns snake.core
  &amp;#40;:require &amp;#91;quil.core :as q #?@&amp;#40;:cljs &amp;#91;:include-macros true&amp;#93;&amp;#41;&amp;#93;
            &amp;#91;quil.middleware :as m&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def world { :width 100 :height 100 :food-amount 1000 }&amp;#41;

&amp;#40;defn gen-food &amp;#91;&amp;#93; &amp;#91;&amp;#40;rand-int &amp;#40;world :width&amp;#41;&amp;#41; &amp;#40;rand-int &amp;#40;world :width&amp;#41;&amp;#41;&amp;#93;&amp;#41;

&amp;#40;defn replenish-food &amp;#91;initial amount&amp;#93;
  &amp;#40;loop &amp;#91;food initial&amp;#93; &amp;#40;if &amp;#40;&amp;gt;= &amp;#40;count food&amp;#41; amount&amp;#41; food &amp;#40;recur &amp;#40;conj food &amp;#40;gen-food&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn wrap &amp;#91;i m&amp;#93;
  &amp;#40;loop &amp;#91;x i&amp;#93; &amp;#40;cond &amp;#40;&amp;lt; x 0&amp;#41; &amp;#40;recur &amp;#40;+ x m&amp;#41;&amp;#41; &amp;#40;&amp;gt;= x m&amp;#41; &amp;#40;recur &amp;#40;- x m&amp;#41;&amp;#41; :else x&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn grow-snake &amp;#91;{:keys &amp;#91;snake velocity&amp;#93; :as state}&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;px py&amp;#93; &amp;#40;map + &amp;#40;peek snake&amp;#41; velocity&amp;#41;&amp;#93;
    &amp;#40;assoc state :snake &amp;#40;conj snake &amp;#91;&amp;#40;wrap px &amp;#40;world :width&amp;#41;&amp;#41; &amp;#40;wrap py &amp;#40;world :height&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn eat &amp;#91;{:keys &amp;#91;snake food&amp;#93; :as state}&amp;#93;
  &amp;#40;if-let &amp;#91;pellet &amp;#40;food &amp;#40;peek snake&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt; state &amp;#40;update :food disj pellet&amp;#41;&amp;#41;
    &amp;#40;-&amp;gt; state &amp;#40;update :snake subvec 1&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn reset? &amp;#91;{:keys &amp;#91;snake&amp;#93; :as state}&amp;#93;
  &amp;#40;if &amp;#40;apply distinct? snake&amp;#41;
    state
    &amp;#40;assoc state :snake &amp;#91;&amp;#40;peek snake&amp;#41;&amp;#93;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn setup &amp;#91;&amp;#93;
  &amp;#40;do &amp;#40;q/smooth&amp;#41;
      &amp;#40;q/frame-rate 30&amp;#41;
      {:snake &amp;#91;&amp;#91;50 50&amp;#93;&amp;#93; :velocity &amp;#91;1 0&amp;#93; :food &amp;#40;replenish-food #{} &amp;#40;world :food-amount&amp;#41;&amp;#41;}&amp;#41;&amp;#41;

&amp;#40;defn draw &amp;#91;{ :keys &amp;#91;snake food&amp;#93; }&amp;#93;
  &amp;#40;let &amp;#91;w &amp;#40;/ &amp;#40;q/width&amp;#41; &amp;#40;world :width&amp;#41;&amp;#41;
        h &amp;#40;/ &amp;#40;q/height&amp;#41; &amp;#40;world :height&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;do
      &amp;#40;q/smooth&amp;#41;
      &amp;#40;q/stroke-cap :round&amp;#41;
      &amp;#40;q/stroke-join :round&amp;#41;
      &amp;#40;q/background 0 0 0&amp;#41;

      &amp;#40;q/fill 0 255 0&amp;#41;
      &amp;#40;q/stroke 0 255 0&amp;#41;
      &amp;#40;doseq &amp;#91;&amp;#91;x y&amp;#93; food&amp;#93;&amp;#40;q/rect &amp;#40;&amp;#42; w x&amp;#41; &amp;#40;&amp;#42; h y&amp;#41; w h&amp;#41;&amp;#41;

      &amp;#40;q/fill 255 0 0&amp;#41;
      &amp;#40;q/stroke 255 0 0&amp;#41;
      &amp;#40;doseq &amp;#91;&amp;#91;x y&amp;#93; snake&amp;#93;&amp;#40;q/rect &amp;#40;&amp;#42; w x&amp;#41; &amp;#40;&amp;#42; h y&amp;#41; w h&amp;#41;&amp;#41;

      &amp;#40;q/fill 0 255 255&amp;#41;
      &amp;#40;q/text &amp;#40;str &amp;quot;Score: &amp;quot; &amp;#40;count snake&amp;#41;&amp;#41; 10 15&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn launch-sketch &amp;#91;{:keys&amp;#91;width height host&amp;#93;}&amp;#93;
  &amp;#40;q/sketch
    :title &amp;quot;Snake&amp;quot;
    :setup setup
    :update #&amp;#40;-&amp;gt; % grow-snake eat &amp;#40;update :food replenish-food &amp;#40;world :food-amount&amp;#41;&amp;#41; reset?&amp;#41;
    :draw draw
    :key-pressed
    &amp;#40;fn &amp;#91;{ :keys &amp;#91;velocity&amp;#93; :as state} { :keys &amp;#91;key key-code&amp;#93; }&amp;#93;
      &amp;#40;case key
        &amp;#40;:a :left&amp;#41; &amp;#40;if &amp;#40;not= &amp;#91;1 0&amp;#93; velocity&amp;#41; &amp;#40;assoc state :velocity &amp;#91;-1 0&amp;#93;&amp;#41; state&amp;#41;
        &amp;#40;:d :right&amp;#41; &amp;#40;if &amp;#40;not= &amp;#91;-1 0&amp;#93; velocity&amp;#41; &amp;#40;assoc state :velocity &amp;#91;1 0&amp;#93;&amp;#41; state&amp;#41;
        &amp;#40;:w :up&amp;#41; &amp;#40;if &amp;#40;not= &amp;#91;0 1&amp;#93; velocity&amp;#41; &amp;#40;assoc state :velocity &amp;#91;0 -1&amp;#93;&amp;#41; state&amp;#41;
        &amp;#40;:s :down&amp;#41; &amp;#40;if &amp;#40;not= &amp;#91;0 -1&amp;#93; velocity&amp;#41; &amp;#40;assoc state :velocity &amp;#91;0 1&amp;#93;&amp;#41; state&amp;#41;
        state&amp;#41;&amp;#41;
    :middleware &amp;#91;m/fun-mode&amp;#93;
    :size &amp;#91;width height&amp;#93;
    #?@&amp;#40;:cljs &amp;#91;:host host&amp;#93;&amp;#41;&amp;#41;&amp;#41;

;#?&amp;#40;:clj &amp;#40;launch-sketch { :width 400 :height 400 }&amp;#41;&amp;#41;

#?&amp;#40;:cljs &amp;#40;defn &amp;#94;:export launch-app&amp;#91;host width height&amp;#93;
           &amp;#40;launch-sketch { :width width :height height :host host}&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;observations&amp;#95;and&amp;#95;comments&quot;&gt;Observations and Comments&lt;/h3&gt;&lt;p&gt;The state in this program is represented by a simple data structure containing a vector describing the snake, a vector representing the snake's velocity, and a set of coordinates representing the locations of food. You can see where I create this at the end of the setup function.There are also some constants in the world def.&lt;/p&gt;&lt;p&gt;To update the state, this program makes use of the common Clojure pattern of &quot;threading state.&quot; Basically, you write your functions so that program state is passed in as an argument and a modified, updated version of the program state is returned. Functions with a single action or concern are written in this manner and then chained to form more complicated behaviors. It makes your program very easy to reason about. In this program you can see where this is done in the update method:&lt;/p&gt;&lt;p&gt;&lt;code&gt;#&amp;#40;-&amp;gt; % grow-snake eat &amp;#40;update :food replenish-food &amp;#40;world :food-amount&amp;#41;&amp;#41; reset?&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;For those unfamiliar with Clojure, I am using the &quot;thread first&quot; macro (The arrow). The # creates an anonymous function with the % as the passed in argument. The arrow takes the argument and feeds it through each function in succession (grow-snake, then eat, then updating food, and so on.).&lt;/p&gt;&lt;p&gt;At the program level, the Quil library handles passing state to each relevant function for processing. In &quot;fun-mode&quot; (functional mode), Quil functions hand you the initial state for modification in methods for program setup, update, and input. For drawing, state is passed in and there is no function output since you will draw your state to the screen. In other applications you can follow this same pattern of state management using Clojure's amazing concurrency primitives (atoms, agents, and refs). In fact Quil is just using an atom under the hood.&lt;/p&gt;&lt;h4 id=&quot;other&amp;#95;minor&amp;#95;details:&quot;&gt;Other minor details:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;There's a commented out form (;#?(:clj (launch-sketch { :width 400 :height 400 }))) towards the end. Uncomment this if you want to launch the file from a REPL. I leave it commented so that it doesn't launch when I do a cljsbuild.&lt;/li&gt;&lt;li&gt;For some reason, the (:gen-class) directive doesn't seem to have any effect in the cljc file, so I have a separate launcher.clj that defines a main method for uberjar builds. Clone the project if you want to see what I mean.You can clone the project &lt;a href='https://github.com/markbastian/snake'&gt;here&lt;/a&gt;. &lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Clojure continues to amaze me by repeatedly enabling me to do so much in such a small amount to time and code. Simple ideas, such as representing your domain as data structures vs. classes and the ability to thread your state throughout your program via functions make development in Clojure rapid and productive. Nowadays, whenever I get an itch to try out a new program or concept, I just sit down and model the domain as data and then start writing functions to manipulate the data. Before I know it, I end up with a complete program. It's a very powerful and fun way to write applications. &lt;/p&gt;
</description>
<pubDate>
Tue, 25 Aug 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-08-06-homoiconic/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-08-06-homoiconic/
</link>
<title>
Clojure is Homoiconic, Java is Not
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Recently I was reading &lt;a href='http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html'&gt;this article&lt;/a&gt; regarding what is (or was) new in Java 8 and took an interest in the following section on Lambdas:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Lambda Expressions, a new language feature, has been introduced in this release. They enable you to treat functionality as a method argument, or code as data. Lambda expressions let you express instances of single-method interfaces (referred to as functional interfaces) more compactly. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I did a quick &lt;a href='https://www.google.com/search?q=java%20lambdas'&gt;Google search&lt;/a&gt; on &quot;java lambdas&quot; and &lt;a href='https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html'&gt;this tutorial was the first hit&lt;/a&gt;. Once again, the same type of statement is made:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The thing that struck me about these articles is the consistent statement that that Java Lambdas (a.k.a. anonymous  instances of single method interfaces) are &quot;code as data&quot; because the function can be passed as an argument. I guess if  you define data as &quot;instances of classes or functions&quot; then this description is fine, but when I read these articles  this is what comes to mind:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/codeasdata.jpg&quot; alt=&quot;alt text&quot; title=&quot;Code as data&quot; /&gt;&lt;/p&gt;&lt;p&gt;Technically, the ability to assign a function to a variable or pass a function as an argument to another function means that your functions are &quot;first class&quot; which is a good thing. However, I would not call this &quot;code as data.&quot; Another related term is &quot;higher order functions.&quot; These are functions that take functions as their arguments or return functions as their results. Again, this is a very powerful language feature that Java now sort of does, but this is not &quot;code as data.&quot;&lt;/p&gt;&lt;p&gt;What do I think of when I think of &quot;code as data?&quot; I think of &quot;Homoiconicity.&quot; Google seems to agree, since when I type &lt;a href='https://www.google.com/search?q=code%20as%20data'&gt;&quot;code as data&quot; into a search box&lt;/a&gt; the first thing that comes up is &lt;a href='https://en.wikipedia.org/wiki/Homoiconicity'&gt;this Wikipedia article on Homoiconicity&lt;/a&gt;. Let's explore the concept in more detail.&lt;/p&gt;&lt;h2 id=&quot;what&amp;#95;is&amp;#95;homoiconicity?&quot;&gt;What is Homoiconicity?&lt;/h2&gt;&lt;p&gt;Often homoiconicity is defined one the following ways:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The code is written in the data structures of the language.&lt;/li&gt;&lt;li&gt;Code as data.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Those more familiar with the concept seem to use &quot;Code as data&quot; more, but I think the first definition is a bit more clear if you are getting started with the idea. Either way, I am going to illustrate the concept by showing how Clojure code is actually written as Clojure data structures. To contrast, I'll also show what &quot;homoiconic Java&quot; would look like. Finally, I'll show you a simple Clojure macro in which we rearrange our code/data.&lt;/p&gt;&lt;h3 id=&quot;homoiconic&amp;#95;clojure&quot;&gt;Homoiconic Clojure&lt;/h3&gt;&lt;p&gt;To start, consider the following core Clojure data structures:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;#40;&amp;#41;&lt;/code&gt; is an empty List.&lt;/li&gt;&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; is an empty Map.&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#91;&amp;#93;&lt;/code&gt; is an empty Vector.&lt;/li&gt;&lt;li&gt;&lt;code&gt;#{}&lt;/code&gt; is an empty Set.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;When we write code in Clojure, it is expressed in terms of the above data structures. Here is a very simple example that applies the str function (it's kind of like .toString) to the number 42:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;user=&amp;gt; &amp;#40;str 42&amp;#41;
&amp;quot;42&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might look at this and think this is the same as the following Java code:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static String str&amp;#40;Integer i&amp;#41;{
    return i.toString&amp;#40;&amp;#41;;
}

str&amp;#40;42&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only difference is the location of the parenthesis, right? Wrong! (str 42) not actually the function str with the argument of 42, but is a list containing two elements, the str symbol and the value 42. When the Clojure evaluator sees a list it attempts to resolve the first symbol (str in this case) and calls that function with the remaining elements of the list as arguments. While this may seem like splitting hairs at the moment, this is very important when you get to macros. It is also crucial to the point that Clojure code is data.&lt;/p&gt;&lt;p&gt;Here's another one:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn add &amp;#91;a b&amp;#93;&amp;#40;+ a b&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, you might think this is the same thing as this Java function:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static int add&amp;#40;int a, int b&amp;#41;{
    return a + b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As before, they are not the same. The above Clojure add function is actually built up with two lists (one nested) and a vector of arguments. The inner list contains three symbols (+, a, and b) and the outer list contains the defn symbol, a symbol naming your function (&quot;add&quot;), a vector of arguments, and our inner list.&lt;/p&gt;&lt;p&gt;Here's another example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;merge-with + { :x 1 :y 2 :z 3 } { :x 9 :y 2 :z 4 }&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By this point you should see that we have a list, two maps, and a bunch of symbols and values as opposed to a function that adds two maps. Yes, the evaluator will merge the maps, but the code itself is data (as in the native data structures of the language).&lt;/p&gt;&lt;p&gt;You can do this type of structural breakdown with any Clojure code. Clojure programs are literal data structures consisting of nested literal data structures, values, and symbols. For more details, read &lt;a href='https://clojure.org/reference/evaluation'&gt;this&lt;/a&gt;. The key takeaway is that we are indeed writing our code as a bunch of data (literal data structures containing nested data structures, values, and symbols).&lt;/p&gt;&lt;h3 id=&quot;homoiconic&amp;#95;java&quot;&gt;Homoiconic Java&lt;/h3&gt;&lt;p&gt;What if you wanted to write Java in its own data structures?&lt;/p&gt;&lt;p&gt;Here are our Java collection interfaces that correspond to the Clojure ones above:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;java.util.List&lt;/li&gt;&lt;li&gt;java.util.Map&lt;/li&gt;&lt;li&gt;java.util.Vector&lt;/li&gt;&lt;li&gt;java.util.Set&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Java, for some inexplicable reason, does not yet have collection literals, so this will be a very verbose exercise. My apologies up front.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/CollectionLiterals.jpg&quot; alt=&quot;alt text&quot; title=&quot;Sad Keanu, No Collection Literals&quot; /&gt;&lt;/p&gt;&lt;p&gt;Ok, now let's write some Java code in the data structures of the language:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    List add = new LinkedList&amp;#40;&amp;#41;;
    add.add&amp;#40;&amp;quot;+&amp;quot;&amp;#41;;
    add.add&amp;#40;1&amp;#41;;
    add.add&amp;#40;1&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, I have no way to evaluate this code, but, hey, it's data. I chose to use a String to represent the + operation because Java doesn't have symbols, either.&lt;/p&gt;&lt;p&gt;Here's another attempt at how I might construct some code as data in Java. I realize that this will be an utter failure, but you're just going to have to follow along as I write a ton of code to make my point.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;    Map a = new HashMap&amp;#40;&amp;#41;;
    a.put&amp;#40;&amp;quot;x&amp;quot;, 1&amp;#41;;
    a.put&amp;#40;&amp;quot;y&amp;quot;, 2&amp;#41;;
    a.put&amp;#40;&amp;quot;z&amp;quot;, 3&amp;#41;;

    Map b = new HashMap&amp;#40;&amp;#41;;
    b.put&amp;#40;&amp;quot;x&amp;quot;, 9&amp;#41;;
    b.put&amp;#40;&amp;quot;y&amp;quot;, 2&amp;#41;;
    b.put&amp;#40;&amp;quot;z&amp;quot;, 4&amp;#41;;
        
    List mergemaps = new LinkedList&amp;#40;&amp;#41;;
    add.add&amp;#40;&amp;quot;merge-with&amp;quot;&amp;#41;;
    add.add&amp;#40;&amp;quot;+&amp;quot;&amp;#41;;
    add.add&amp;#40;a&amp;#41;;
    add.add&amp;#40;b&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, this can't be evaluated, but it's about as close as you can get to homoiconicity in Java.&lt;/p&gt;&lt;h2 id=&quot;why&amp;#95;homoiconicity?&amp;#95;-&amp;#95;macros&quot;&gt;Why Homoiconicity? - Macros&lt;/h2&gt;&lt;p&gt;Consider this question: &quot;What can you do with data?&quot; Think about an Excel spreadsheet, a simple comma separated value file, or some JSON data. These are things you can easily sort, manipulate, and transform.&lt;/p&gt;&lt;p&gt;In the same way, Clojure code can be manipulated and transformed as data. In Clojure there is a facility for this called a macro. When Clojure evaluates macros, it does not evaluate the arguments as with a regular function. Rather, it passes the unevaluated arguments into the macro to be manipulated. Once this is done, the result is returned and evaluated.&lt;/p&gt;&lt;p&gt;Here's an example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmacro bizzaro-math
  &amp;quot;Do everything the opposite of normal&amp;quot;
  &amp;#91;&amp;#91;op &amp;amp; rest&amp;#93;&amp;#93;
  &amp;#40;conj rest &amp;#40;case op
               + -
               - +
               &amp;#42; /
               / &amp;#42;
               op&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This macro takes its arguments and inverts the first argument if it is a basic arithmetic operator. Note that this would not be possible if the arguments were evaluated rather than treated as data. Here are some examples of it in use:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;bizzaro-math &amp;#40;+ 2 3&amp;#41;&amp;#41;
=&amp;gt; -1
&amp;#40;bizzaro-math &amp;#40;- 2 3&amp;#41;&amp;#41;
=&amp;gt; 5
&amp;#40;bizzaro-math &amp;#40;&amp;#42; 2 3&amp;#41;&amp;#41;
=&amp;gt; 2/3
&amp;#40;bizzaro-math &amp;#40;/ 2 3&amp;#41;&amp;#41;
=&amp;gt; 6
&amp;#40;bizzaro-math &amp;#40;rem 2 3&amp;#41;&amp;#41;
=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The most important thing to note here is that the inner forms (e.g. (+ 2 3)) are not evaluated, but are manipulated by the macro, then evaluated. This is the ultimate demonstration that we do, indeed, have code as data.&lt;/p&gt;&lt;p&gt;A more in-depth discussion of macros is beyond the scope of this post, but the main takeaway is that macros allow you to manipulate code. This is a feature unique to homoiconic languages.&lt;/p&gt;&lt;h2 id=&quot;parting&amp;#95;thoughts&quot;&gt;Parting Thoughts&lt;/h2&gt;&lt;p&gt;Code as data, a.k.a. homoiconicity, is the ability to write your code in the data structures of your language. This goes way beyond the simple ability to pass a function as an argument. If that's all you are looking for, Java might be all you need. If you want full on FP on the JVM, you've got better options. Scala is a great bridge language that has first class functions, higher order functions, partial evaluation, composition, and all the other things you'd expect from a functional language. Clojure, however, is King if want it all. Not only is it functional, it is truly homoiconic.&lt;/p&gt;&lt;p&gt;Further Reading:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://www.paulgraham.com/avg.html'&gt;Beating the Averages&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.braveclojure.com/read-and-eval/#5__Macros'&gt;Clojure For the Brave and True&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojure.org/reference/macros'&gt;Clojure Macros&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Thu, 06 Aug 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-07-22-three/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-07-22-three/
</link>
<title>
Three Reasons You May Not Want to Learn Clojure
</title>
<description>
 &lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;I've been coding in Clojure for over a year now and not everything is unicorns and rainbows. Whatever language you choose will affect how you think and work and Clojure is no different. Read on to see what some of these effects are and why you might want to reconsider learning Clojure.  &lt;/p&gt;&lt;h3 id=&quot;you&amp;#95;will&amp;#95;write&amp;#95;at&amp;#95;least&amp;#95;10x&amp;#95;less&amp;#95;code&amp;#95;than&amp;#95;your&amp;#95;java&amp;#95;counterparts&quot;&gt;You will write at least 10X less code than your Java counterparts&lt;/h3&gt;&lt;p&gt;Often, the measure of a library or project is its size. Programmers like to compare the size of their projects, just like muscle car people like to compare the size of their engines. Here are some situations where this might happen:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Lunch with buddies&lt;/li&gt;&lt;li&gt;Job interview&lt;/li&gt;&lt;li&gt;Internal performance evaluation &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here's a typical conversation:  &lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You: &quot;Yeah, I just finished delivering the Awesome 2000.&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Them: &quot;Oh, yeah? Tell me about it.&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;You: &quot;Well, it is this software product that simultaneously creates world peace, solves world hunger, and saves the environment. Zero carbon footprint, too.&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Them: &quot;Cool, how many lines of code was that?&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;You: &quot;Oh, like 2 million.&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Them: &quot;Wow, awesome.&quot; &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;You will now get a high five, a job offer, or a big raise depending on who you are talking with. However, if you stated that the number of lines of code in your product was 200 then the response might be more along the lines of &quot;Oh, a toy program written in a toy language.&quot; For some reason, probably because it is easy, many people like to equate lines of code with programming ability rather than some other metric like, oh, I don't know, the actual features of the programs you've developed. Clojure, sadly, excels at implementing features but is very poor at being verbose about it.&lt;/p&gt;&lt;p&gt;If you want to demonstrate your ability to code by writing lots of it, Clojure is a terrible, horrible, no-good language. I can't think of another language that is worse in this respect. You will never be able to brag again, in an circumstance, about how big your code base is compared to someone else's.&lt;/p&gt;&lt;h3 id=&quot;you&amp;#95;won't&amp;#95;be&amp;#95;marketable&amp;#95;for&amp;#95;certain&amp;#95;jobs&quot;&gt;You won't be marketable for certain jobs&lt;/h3&gt;&lt;p&gt;True Story: Once upon a time I was at a job interview and the interview panel asked me to go up to the board and code up a Fibonacci sequence generator. I asked what language they wanted it in and they said they didn't care, but they were a C++ shop. Since they didn't care, I wrote a very short tail-recursive Scala version which I am sure they found incomprehensible. I used to program in C++ and at one time I think I was quite good at it. However, I am just not that interested in C++ any more. It was a great job interview because I didn't get the job. I am sure that the story would have ended the same had I done the exercise in Clojure, except for the parenthesis would have been in the right place.&lt;/p&gt;&lt;p&gt;If you want to be a professional Clojure programmer, there will be a smaller number of job openings for someone of your skills and interests than for the standard Java or C# developer. If you are interested in being part of a clone army doing widely-available boring work, Clojure is not for you.&lt;/p&gt;&lt;h3 id=&quot;you&amp;#95;will&amp;#95;get&amp;#95;things&amp;#95;done&amp;#95;faster&quot;&gt;You will get things done faster&lt;/h3&gt;&lt;p&gt;Clojure makes you productive, really productive. So, if you can get a product to market 3-10 times faster than you once could, what does your employer do with all that extra time you just bought them? Fire you and pocket the savings, that's what! Just kidding. Mostly.&lt;/p&gt;&lt;p&gt;While it is true that a company might take advantage of their newfound savings in cost and time by eliminating the software team that just bought them the savings, the more likely scenario is that 1) they will reapply you to something else; or 2) if they are trimming fat, you aren't part of it. Often you will become the new go-to person for getting things done because you've demonstrated an ability to get things done. This does lead to another problem: You have too much work to do because you are a productivity magnet.&lt;/p&gt;&lt;p&gt;While you can't predict what your employer will do in a given situation, one constant you can be sure of in the current software job market is that you must be agile. If you demonstrate value you can be sure that will have the opportunity to continue to demonstrate value. If, on the other hand, you resist change you will eventually be phased out by your own employer or by another company that displaces yours entirely.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Yes, Clojure is an enabling and empowering language, but this is not without its down sides. I didn't even get into some of the other issues, like not having the opportunity to rewrite your Java code in JavaScript because Clojure compiles both ways. If these are the kinds of problems you like to deal with, you just might want to give Clojure a try.&lt;/p&gt;&lt;h3 id=&quot;shameless&amp;#95;plug&quot;&gt;Shameless Plug&lt;/h3&gt;&lt;p&gt;Like this blog? Please share, subscribe, or follow it (just enter your email at the top right).&lt;/p&gt;
</description>
<pubDate>
Wed, 22 Jul 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-07-14-quilwora/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-07-14-quilwora/
</link>
<title>
Quil, Clojure, and WORA
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Since my last post, I've been playing with the excellent &lt;a href='http://quil.info'&gt;Quil library&lt;/a&gt;, a &quot;Clojure/ClojureScript library for creating interactive drawings and animations.&quot; Prior to this, I was writing demonstrations using the following scheme:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Develop all logic using cljc files (cljx before Clojure 1.7). In general, application logic is pretty platform-independent and can be wholly or nearly-wholly written in whatever language you are working in (Clojure in our case). Any slight variances (e.g. having to create a java.util.Date or a JavaScript Date) can easily be handled by &lt;a href='https://dev.clojure.org/display/design/Reader+Conditionals'&gt;Clojure's new Reader Conditionals&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Decide on a UI technology (likely Java Swing with Java2D or HTML Canvas depending on what type of demo I wanted) and implement a front end using that particular choice.&lt;/li&gt;&lt;li&gt;Optionally implement the &quot;other&quot; solution from #2 so that I now have a Java and JavaScript solution.This strategy works pretty well, but I still have duplication of effort when it comes to the user experience. The awesome thing about Quil is that it allows you to launch your UI as either a Clojure or ClojureScript application targeting the JVM or JavaScript-enabled browser, respectively. Now, I can pretty much write everything as cljc files with a few reader conditionals and easily produce targets that run on the JVM or in a browser.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;To get my feet wet with Quil, I re-implemented the renderer for my &lt;a href='../2015-06-24-lander/'&gt;Lunar Lander project&lt;/a&gt; in Quil. I was so happy with the results that I removed the Canvas/ClojureScript renderer completely and now just use a single renderer for both the JVM and JS versions of the project.&lt;/p&gt;&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;&lt;p&gt;By the time I was done with my new rendering code and refactoring of everything else, all of the cljs files were gone. I now have a single clj file that is nothing more than a (:gen-class) macro and a main function calling the application entry point in the cljc code. Everything else is written as cljc files. Only a small number of reader conditionals were used to make any Clojure or ClojureScript specific changes as required. Rather than go over every example of how I used reader conditionals, take a look at &lt;a href='https://github.com/markbastian/lander/blob/master/src/cljc/lander/game_launcher.cljc'&gt;this file&lt;/a&gt; that demonstrates how to create a single Quil &quot;Sketch&quot; that works with both host platforms. Aside from the above linked file, the only other conditionals required were a couple java.util.Date vs. JavaScript Date conditionals used in the simulation namespace. The vast majority of the code was identical for all hosts.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I've been developing code for the JVM for over 10 years and have always liked the &quot;Write once, run anywhere&quot; (WORA) aspect of JVM languages, and have found that WORA works for the most part. However, you can't always rely on your host machine having a modern JVM, especially in the era of mobile devices. The browser is really the most ubiquitous host platform, and the ability to write a single application that can be compiled to run as a JVM app or a JavaScript app with very little effort is a huge advantage for Clojure and Clojurists.&lt;/p&gt;&lt;h2 id=&quot;afterthoughts&quot;&gt;Afterthoughts&lt;/h2&gt;&lt;p&gt;The complete application described in this blog can be found &lt;a href='https://github.com/markbastian/lander'&gt;here&lt;/a&gt;. Note that you will need to build and install my &lt;a href='https://github.com/markbastian/numerics'&gt;numerics&lt;/a&gt; project as well. Once numerics is installed, cd over to lander and type lein run for the Clojure version of the game. You can play the web version right here (Note that you will need a keyboard or some way to emulate the 'f' key and left and right arrow keys.).&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas height=&quot;400&quot; id=&quot;quil-lander-canvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;../../js/quil-lander.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;lander.game_launcher.launch(document.getElementById(&quot;quil-lander-canvas&quot;), 400, 400);&lt;/script&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;Note that due to the way markdown munges underscores I needed to update the js file used for this demo. The new file  includes some additional features such as a fuel budget. Good luck!&lt;/p&gt;
</description>
<pubDate>
Tue, 14 Jul 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-06-24-lander/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-06-24-lander/
</link>
<title>
A Lunar Lander Game in Clojure
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;In a prior post, I spent a great deal of time &lt;a href='../2015-04-28-predator-prey/'&gt;talking about Predator-Prey systems&lt;/a&gt;, ordinary differential equations, and solving these equations in Clojure. In this post, I describe a recent project I did that uses the same ODE solver to do something much more fun - implement a physics-based lunar lander game.&lt;/p&gt;&lt;p&gt;Here are the rules and operations for the game:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;To win, you must land the lander on the terrain with a rotation of 0 and an absolute vertical velocity less than 10 m/s.&lt;/li&gt;&lt;li&gt;To engage the lander's thruster, press the 'f' key or space bar.&lt;/li&gt;&lt;li&gt;To turn the lander, press the left and right arrow keys.&lt;/li&gt;&lt;li&gt;If you go off the edge of the screen, land too fast, or land at an angle, you lose.&lt;/li&gt;&lt;li&gt;Press enter to start/restart the game.The simplest solution is to just press the space bar when you get pretty close to the ground and carefully tap it so that you land very slowly. To give yourself a little challenge, turn the lander and give yourself some horizontal thrust. Then try to land it. I may later enhance the game with landing zones so you can't just land anywhere, but for now you can land anywhere you want.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Without further ado, here's the game: &lt;canvas height=&quot;400&quot; id=&quot;canvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;../../js/lander.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;lander.lunarlander.init(document.getElementById(&quot;canvas&quot;));&lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;script&gt; window.onkeydown = function(e) {  return !(e.keyCode == 32); }; &lt;/script&gt;&lt;/p&gt;&lt;p&gt;If you are reading this blog via an aggregator that doesn't pick up the .js content, this is what the game looks like:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/lander.jpg&quot; alt=&quot;alt text&quot; title=&quot;Lander&quot; /&gt;&lt;/p&gt;&lt;h3 id=&quot;implementation/clojure&amp;#95;details&quot;&gt;Implementation/Clojure Details&lt;/h3&gt;&lt;p&gt;Now that you've had some fun trying the game out, here are a few high points. I won't go into a lot of detail in most of these sections since each could be a post in and of itself, but I will spend a good amount of time on multimethods, which were a big win in this application. If you want to build it, the entire project is available at &lt;a href='https://github.com/markbastian/lander'&gt;https://github.com/markbastian/lander&lt;/a&gt;.  Note that you will need to clone &lt;a href='https://github.com/markbastian/numerics'&gt;my numerics library&lt;/a&gt; for the Runge-Kutta solver and lein install it.&lt;/p&gt;&lt;h4 id=&quot;platform&amp;#95;compatibility&quot;&gt;Platform Compatibility&lt;/h4&gt;&lt;p&gt;Clojure 1.7 (Currently RC2) has the new cljc extension, which makes cross-compiling Clojure and ClojureScript a breeze. It is much easier and faster than the old cljx solution. I didn't make a JVM-based solution in parallel this time, but it would be pretty easy.&lt;/p&gt;&lt;h4 id=&quot;game&amp;#95;physics&quot;&gt;Game Physics&lt;/h4&gt;&lt;p&gt;This was one of the easiest parts of the game since I just modeled the lander using differential equations and stepped forward using a Runge-Kutta integrator at each simulation step. The differential equations are:&lt;/p&gt;&lt;p&gt;&amp;#92;({dp\over dt} = v&amp;#92;)&lt;/p&gt;&lt;p&gt;&amp;#92;({dv\over dt} = -9.81 + thrust&amp;#92;)&lt;/p&gt;&lt;p&gt;Thrust is only applied when the user turns it on and the actual solution breaks the position (p) and velocity (v) vectors up into their x and y components.&lt;/p&gt;&lt;p&gt;And here's the code:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmethod sim :live &amp;#91;state-ref&amp;#93;
  &amp;#40;let &amp;#91;{:keys &amp;#91;theta thrust time state&amp;#93;} @state-ref
        t &amp;#40;.getTime &amp;#40;js/Date.&amp;#41;&amp;#41;
        dt &amp;#40;&amp;#42; &amp;#40;- t time&amp;#41; 1E-3&amp;#41;
        dvx #&amp;#40;-&amp;gt; theta &amp;#40;&amp;#42; Math/PI&amp;#41; &amp;#40;/ -180&amp;#41; Math/sin &amp;#40;&amp;#42; thrust&amp;#41;&amp;#41;
        dvy #&amp;#40;+ -9.81 &amp;#40;-&amp;gt; theta &amp;#40;&amp;#42; Math/PI&amp;#41; &amp;#40;/ -180&amp;#41; Math/cos &amp;#40;&amp;#42; thrust&amp;#41;&amp;#41;&amp;#41;
        new-states &amp;#40;rk/rk-step &amp;#91;#&amp;#40;% 3&amp;#41; #&amp;#40;% 4&amp;#41; dvx dvy&amp;#93; state dt tableaus/classic-fourth-order&amp;#41;&amp;#93;
    &amp;#40;swap! state-ref into { :state new-states :time t }&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;terrain&quot;&gt;Terrain&lt;/h4&gt;&lt;p&gt;Terrain is generated using the midpoint displacement method (source). Read about it here. Every new game procedurally generates a new terrain profile. There's a good chance I'll do a full on 3D terrain generation algorithm for a future blog post.&lt;/p&gt;&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;&lt;p&gt;State is held in a single atom. As usual, when writing Clojure apps, I just modeled my problem as a data structure held by a Clojure concurrency primitive and everything else fell into place. The values tracked were game state (discussed later in the multimethods section), physical simulation state, time, theta (the lander's rotation), thrust (toggled on and off by user input), and terrain. All of this was easily managed in a single atom. One of the most beautiful things about Clojure is the simplicity of modeling your domain. When you stop thinking in objects and start thinking in terms of data and functions on data, life becomes much simpler.&lt;/p&gt;&lt;h4 id=&quot;project&amp;#95;size&quot;&gt;Project Size&lt;/h4&gt;&lt;p&gt;The project is ~200 LOC. Not too shabby for a complete game. There are certainly areas where I could have further reduced the amount of code, such as in the rendering section, but there comes a point where everything works fine and there's no need to mess with it further. Although I don't believe in brevity for brevity's sake, I do believe less code is easier to maintain and navigate than more code, so I always appreciate a concise solution.&lt;/p&gt;&lt;h3 id=&quot;multimethods&amp;#95;-&amp;#95;the&amp;#95;big&amp;#95;win&quot;&gt;Multimethods - The Big Win&lt;/h3&gt;&lt;p&gt;In a computer game, you will have different stages of play, or game states (not to be confused with the physics state being maintained in the sim loop). For example, when you start a game there is a setup stage. Once everyone has joined there is a main game phase in which most play occurs. Finally, when someone wins there is usually some sort of congratulatory display or an option to play again. Each stage or game state entails a different set of rules regarding what input is received, what is rendered, and so on. However, each state has common functions such as receiving input and rendering. This is where Clojure multimethods come into play - they allow you to call the same overall game logic, but dispatch different functions based on some custom function.&lt;/p&gt;&lt;p&gt;In this game, the game is in one of four states:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;:before - The state of being before any game has been played.&lt;/li&gt;&lt;li&gt;:live - A game is currently being played.&lt;/li&gt;&lt;li&gt;:win - A game has been played and you won.&lt;/li&gt;&lt;li&gt;:lose - A game has been played and you lost.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Depending on the state of the lander game, different logic is executed for the input, rendering, and simulation functions. For example, in :before, :win, and :lose state the game only allows you to start/restart a game, where in :live state the game accepts input to control the lander. In :live state the game renders the lander, terrain, and stats. In :before state the game only renders its directions.&lt;/p&gt;&lt;p&gt;The cool thing about all of this is that in Clojure I only have one main game loop (shown below). It repeatedly calls game-state, state, and render. At the same time, input is taken via the handle-keydown and handle-keyup methods. What happens when these methods are invoked depends on the current game state, with the right logic being dispatched via multimethods.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;#94;:export init&amp;#91;canvas&amp;#93;
  &amp;#40;set!
    &amp;#40;.-onload js/window&amp;#41;
    &amp;#40;let &amp;#91;state &amp;#40;atom { :game-state :before }&amp;#41;&amp;#93;
      &amp;#40;do
        &amp;#40;js/setInterval #&amp;#40;do
                          &amp;#40;gs/game-state state&amp;#41;
                          &amp;#40;sim/sim state&amp;#41;
                          &amp;#40;render/render state canvas&amp;#41;&amp;#41; 1&amp;#41;
        &amp;#40;set! &amp;#40;.-onkeydown js/document&amp;#41; &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;in/handle-keydown state e&amp;#41;&amp;#41;&amp;#41;
        &amp;#40;set! &amp;#40;.-onkeyup js/document&amp;#41; &amp;#40;fn &amp;#91;e&amp;#93; &amp;#40;in/handle-keyup state e&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how it is done. I have 5 methods that I am invoking polymorphically based on the current game state (Note that they are shown together here, but are in separate files in the project):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;Watch the actual game state and transition to a new state based on the current physical state.
&amp;#40;defmulti game-state &amp;#40;fn &amp;#91;state&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;

;Simulate the physics of the game based on the game state.
&amp;#40;defmulti sim &amp;#40;fn &amp;#91;state&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;

;Draw to the screen based on the game state.
&amp;#40;defmulti render &amp;#40;fn &amp;#91;state &amp;#95;&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;

;Handle input based on the game state.
&amp;#40;defmulti handle-keydown &amp;#40;fn &amp;#91;state &amp;#95;&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;
&amp;#40;defmulti handle-keyup &amp;#40;fn &amp;#91;state &amp;#95;&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The actual function dispatched when a defmulti is called depends on the dispatch function. In this case the dispatch function is (fn [state] (@state :game-state)). Now that I've defined the multimethods and their dispatch functions, I need to create methods that dispatch based on the right game state. Here's how it works for the render multimethod:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmulti render &amp;#40;fn &amp;#91;state &amp;#95;&amp;#93; &amp;#40;@state :game-state&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defmethod render :before &amp;#91;&amp;#95; canvas&amp;#93; &amp;#40;intro-screen canvas&amp;#41;&amp;#41;

&amp;#40;defmethod render :win &amp;#91;state canvas&amp;#93;
  &amp;#40;do
    &amp;#40;draw canvas @state&amp;#41;
    &amp;#40;win-screen canvas&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defmethod render :lose &amp;#91;state canvas&amp;#93;
  &amp;#40;do
    &amp;#40;draw canvas @state&amp;#41;
    &amp;#40;lose-screen canvas&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defmethod render :live &amp;#91;state canvas&amp;#93; &amp;#40;draw canvas @state&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, given the state of the game, different render methods are called based on the state of the game. The same is true for all of the other multimethods defined above. For example, the :live method for the sim multi method was shown earlier. When the game is not in a live state, it simply calls the method show below, which conveniently makes the lander stop wherever it was when the game ended.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmethod sim :default &amp;#91;state-ref&amp;#93; &amp;#40;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I won't go through all of the methods I defined, but you should get the idea from what I've posted. Multimethods provide a very effective and powerful way to dynamically dispatch different behaviors based on a custom defined function.&lt;/p&gt;&lt;p&gt;Finally, I could have defined my multimethods in one common namespace and provided implementations in another. Had I chose to provide both HTML Canvas and Swing/Graphics2D versions of this application, I could have implemented a single game loop that performs all logic in terms of multimethods and defined implementations in separate namespaces. Depending on which version of the application I wanted to run I would require the corresponding namespaces.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In this post, I presented a lunar lander game written in Clojure along with some observations about the code. As with my other Clojure projects, I am impressed by how I can make a non-trivial application with such a small amount of code. Various aspects of Clojure contributed to this, but the thing that most impressed me with this particular application was the use of multimethods to easily transition between game states and manage which functions should be dispatched under what conditions.&lt;/p&gt;
</description>
<pubDate>
Wed, 24 Jun 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-06-11-differences/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-06-11-differences/
</link>
<title>
Differences between Null, Nil, nil, Some, and None
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;During a recent code review, a coworker who had the good fortune of jumping straight from  Java to Clojure was asking me a few questions about some Scala code she'd been asked to edit.  The particular problem involved recursive accumulation of some list data and our conversation  drifted towards some questions regarding the different-yet-similar-sounding terms in these JVM  languages. Java, Scala, and Clojure together have Null, Nil, nil, Some, and None. Most of these  are related in their respective languages to how exceptional behaviors are handled with respect  to references and/or collections. Here I explain each of these from the perspective of their host  languages and my opinion of the effectiveness of each solution.    &lt;/p&gt;&lt;p&gt;Before diving in, let me be clear that null exists in all JVM languages, including Scala and  Clojure. However, these and other more modern languages provide additional facilities for dealing  with situations where Java would default to using null and/or throw NPEs. &lt;/p&gt;&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;&lt;p&gt;In Java, you may encounter null when using an uninitialized reference (the default value for all references is null), when attempting to get a collection element that doesn't exist, or when  someone decides to return null from their function to indicate a bad result. Java has no special  handling for null. If you try doing anything with a null value, you get a NullPointerException  and all is lost.    &lt;/p&gt;&lt;p&gt;Not only is trying to do something with null exceptionally bad, Java (pre 8) has no built-in  mechanisms to help you out. You just do lots of null checking.&lt;/p&gt;&lt;p&gt;Here are some methods for dealing with null in Java:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Always check your references. Liberally spread if(foo != null){ /&lt;em&gt;Do stuff with foo here&lt;/em&gt;/ }everywhere you don't have absolute control of your references and aren't absolutely sure foo is initialized.&lt;/li&gt;&lt;li&gt;Always initialize your references at declaration or (preferably) make them final.Effective Java Item #15 says &quot;Minimize Mutability.&quot; I find it very hard to be effective when writing Java, but this is definitely a good tip. Whenever possible, make everything final with a meaningful (i.e. non-null) value.&lt;/li&gt;&lt;li&gt;Don't write your code in Java. There are some perfectly good alternatives (See below).&amp; Use the new Optional class from Java 8. This is the similar to Scala's Option type so I won't say much here aside from saying that Scala had it first. There's a trend there.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;scala&quot;&gt;Scala&lt;/h3&gt;&lt;p&gt;Recognizing the evils of null and NullPointerExceptions, Scala designed a better way -  the Option type. Rather than returning null when something goes bad, the Scala way is to  return either Some value if the computation succeeded or None if it failed. Here is an  example of how you might use Option types to model a random food grab into your refrigerator:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;  /&amp;#42;&amp;#42;
   &amp;#42; A really lame function that might return a random food.
   &amp;#42;/
  def randomFood = math.random match {
    case x if x &amp;gt; 0.75 =&amp;gt; Some&amp;#40;&amp;quot;Ham&amp;quot;&amp;#41;
    case x if x &amp;gt; 0.5 =&amp;gt; Some&amp;#40;&amp;quot;Cheese&amp;quot;&amp;#41;
    case x if x &amp;gt; 0.25 =&amp;gt; Some&amp;#40;&amp;quot;Bacon&amp;quot;&amp;#41;
    case &amp;#95; =&amp;gt; None
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you made a call to randomFood you could then call isDefined or isEmpty on the result to  see if a meaningful result was returned. If the result is meaningful you can then call get  to retrieve the value stored in the Some. In reality, nobody ever does this because it isn't  any better than performing a null check. The only time you might do this is when calling   Scala from Java because Java doesn't understand Scala functions.&lt;/p&gt;&lt;p&gt;What people really do with Options is use the fact that Scala implicity converts them to  Iterables to perform functional operations on them. You can use functions on Options like  map, foreach, flatten, reduce, and so on. Here's an example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;val sandwich = Some&amp;#40;&amp;quot;Bread&amp;quot;&amp;#41; ::
  &amp;#40;&amp;#40;0 until 10&amp;#41; map { &amp;#95; =&amp;gt; randomFood }&amp;#41;.toList :::
  Some&amp;#40;&amp;quot;Bread&amp;quot;&amp;#41; :: Nil

//Prints something like List&amp;#40;Some&amp;#40;Bread&amp;#41;, Some&amp;#40;Ham&amp;#41;, Some&amp;#40;Ham&amp;#41;, None, Some&amp;#40;Bacon&amp;#41;, Some&amp;#40;Bacon&amp;#41;, Some&amp;#40;Ham&amp;#41;, None, Some&amp;#40;Ham&amp;#41;, Some&amp;#40;Bacon&amp;#41;, None, Some&amp;#40;Bread&amp;#41;&amp;#41;
println&amp;#40;sandwich&amp;#41;

//Prints something like List&amp;#40;Bread, Ham, Ham, Bacon, Bacon, Ham, Ham, Bacon, Bread&amp;#41;
println&amp;#40;sandwich.flatten&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Scala also has Nil, which is the empty list. Nil is the odd man out in this post as it is  a specific instance of an empty collection rather than a construct for handling exceptional  behavior, especially with respect to null. Due to Scala's powerful type system and inferencing,  the Scala compiler will figure out what kind of list you are working with as soon as you add  some items to your list.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;scala&amp;gt; val x = 1 :: 2 :: 3 :: Nil
x: List&amp;#91;Int&amp;#93; = List&amp;#40;1, 2, 3&amp;#41;

scala&amp;gt; Nil
res0: scala.collection.immutable.Nil.type = List&amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see in the last line, Nil can't infer a type when no elements of any type  are provided. Sometimes using empty collections like this in Scala can cause problems  in which the compiler can't infer the type information. In such cases, you can just declare the type when declaring the def or val (we don't use vars).  Here's an example that illustrates the point:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;scala&amp;gt; Some&amp;#40;4&amp;#41; map { x =&amp;gt; x &amp;#42; x } getOrElse 0
res0: Int = 16

scala&amp;gt; Some&amp;#40;4.0&amp;#41; map { x =&amp;gt; x &amp;#42; x } getOrElse 0
res1: AnyVal = 16.0

scala&amp;gt; None map { x =&amp;gt; x &amp;#42; x } getOrElse 0
&amp;lt;console&amp;gt;:8: error: value &amp;#42; is not a member of Nothing
              None map { x =&amp;gt; x &amp;#42; x } getOrElse 0
                                &amp;#94;
scala&amp;gt; val n : Option&amp;#91;Double&amp;#93; = None
n: Option&amp;#91;Double&amp;#93; = None

scala&amp;gt; n map { x =&amp;gt; x &amp;#42; x } getOrElse 0
res3: AnyVal = 0

scala&amp;gt; n map { x =&amp;gt; x &amp;#42; x } getOrElse 0.0
res4: Double = 0.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As can be seen from the example, using operations such as map and getOrElse are convenient ways to transform Optional  types to desired outputs. At the same time, care must be taken to make sure type information isn't lost so that you get  the expected result. Despite these potential pitfalls, Scala's ability to treat Options as Iterables makes dealing with  them very convenient.&lt;/p&gt;&lt;p&gt;Overall, Option is a much better solution than dealing with frequent null checking.&lt;/p&gt;&lt;h3 id=&quot;clojure&quot;&gt;Clojure&lt;/h3&gt;&lt;p&gt;Being hosted on the JVM, Clojure's nil is identical to Java's null. However, how Clojure treats nil is very different  from Java. Rather than exploding every time nil is used a la Java or adding special features to handle exceptional  behavior a la Scala, Clojure has a few simple rules that make it easy to work with nil. First, in logical expressions  nil logically evaluates to false (along with false itself). In Clojure we call this &quot;truthiness&quot; and it is awesome.  Second, when dealing with collections nil is treated like an empty list. These simple rules result in a simple, elegant solution to the dreaded null problem and it also results in a lot less code. To illustrate, here's our random food grab  function in Clojure:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn rand-food &amp;#91;&amp;#93;
  &amp;#40;condp &amp;lt; &amp;#40;rand&amp;#41;
    0.75 &amp;quot;Ham&amp;quot;
    0.5 &amp;quot;Cheese&amp;quot;
    0.25 &amp;quot;Bacon&amp;quot;
    nil&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, I don't do anything special (No Some/None construct) and just return nil (which is null in Java).  It is the simplest solution, which is what Clojure is all about. In Java, this solution would be error-prone since  it is using null. Here's how it works in Clojure:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;let&amp;#91;food &amp;#40;take 10 &amp;#40;repeatedly rand-food&amp;#41;&amp;#41;
     layers &amp;#40;filter identity food&amp;#41;&amp;#93;
  &amp;#40;conj &amp;#40;into &amp;#91;&amp;quot;Bread&amp;quot;&amp;#93; layers&amp;#41; &amp;quot;Bread&amp;quot;&amp;#41;&amp;#41;
=&amp;gt; &amp;#91;&amp;quot;Bread&amp;quot; &amp;quot;Ham&amp;quot; &amp;quot;Bacon&amp;quot; &amp;quot;Cheese&amp;quot; &amp;quot;Ham&amp;quot; &amp;quot;Bacon&amp;quot; &amp;quot;Ham&amp;quot; &amp;quot;Bacon&amp;quot; &amp;quot;Bacon&amp;quot; &amp;quot;Ham&amp;quot; &amp;quot;Ham&amp;quot; &amp;quot;Bread&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here's another snippet of examples that show how Clojure deals with nil when it is placed in the position of a null  argument or collection. Compare or in Clojure with getOrElse in Scala. Much simpler.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;&amp;#40;reduce + &amp;#40;map #&amp;#40;&amp;#42; % %&amp;#41; &amp;#91;1 2 3&amp;#93;&amp;#41;&amp;#41; ;A non-nil example
=&amp;gt; 14
&amp;#40;reduce + &amp;#40;map #&amp;#40;&amp;#42; % %&amp;#41; nil&amp;#41;&amp;#41; ;I can reduce into a nil collection
=&amp;gt; 0
&amp;#40;or nil 4&amp;#41; ;Compare to getOrElse in Scala
=&amp;gt; 4
&amp;#40;and nil 4&amp;#41; ;Both items must exist
=&amp;gt; nil
&amp;#40;conj nil 4&amp;#41; ;I can conjoin 4 to nil to create the list &amp;#40;4&amp;#41;
=&amp;gt; &amp;#40;4&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As with Scala, Clojure provides a better way to handle null than Java. In contrast to Scala, Clojure does not add any  special classes to handle null. Rather, it uses slightly different rules so that nil has meaning in collection and logical operations. For more on nil in Clojure, read about &quot;nil punning&quot; &lt;a href='http://www.lispcast.com/nil-punning'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Hands down, I prefer Clojure's handling of nil to either Scala or Java's approach.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Null is a unavoidable fact of life. Sometimes things go wrong and the best answer is no answer. How this situation is  dealt with depends very much on the language you are working in. Java, realizing that null is bad, throws lots of  exceptions that you get to deal with, usually with lots of error checking. Scala provides a mechanism to return  something (Some value) or nothing (None) that allows you to more easily deal with situations that might go bad.  Clojure has a few rules for how to deal with nil, primarily the concepts of &quot;truthiness&quot; and treating nil like an  empty list. The rules pretty much solve all your problems when it comes to nil.&lt;/p&gt;&lt;p&gt;These approaches shed light on the designs of these languages, especially the more recent ones. Scala is, in my opinion,  a complicated language that solves many problems via additional mechanisms to deal with the problems inherited from  Java. I still think it is a great language, but it does take a decidedly baroque approach to solving problems. Clojure,  despite seeming otherworldly at first, is a truly simple language. The more I use it, the more impressed I am with its  simple design and philosophy. Either way, I think you'll find either of these language's solutions to the null problem  preferable to Java's.&lt;/p&gt;
</description>
<pubDate>
Thu, 11 Jun 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-05-27-exercises/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-05-27-exercises/
</link>
<title>
Exercises in Clojure with Commentary
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;I was recently browsing some links from my Twitter feed and came across some programming exercises and their solutions. I selected a few that I thought were interesting, solved them, and now I want to present my solutions here along with some commentary on how they were solved. I think the solutions and especially their comments might be helpful to new Clojurists as well as Java developers who are looking for some examples of why Clojure code is so much more concise. Without further ado, here they are.&lt;/p&gt;&lt;h3 id=&quot;problem&amp;#95;1:&amp;#95;square&amp;#95;code/crypto&amp;#95;square&quot;&gt;Problem 1: Square Code/Crypto Square&lt;/h3&gt;&lt;p&gt;Read all about it &lt;a href='https://github.com/trikitrok/MyExercismExercises/blob/master/clojure/crypto-square/README.md'&gt;here&lt;/a&gt;  and &lt;a href='http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html#easy'&gt;here&lt;/a&gt;.  Basically, you do the following to encode a text string:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Convert the initial string to a lowercase character string with only alpha characters&lt;/li&gt;&lt;li&gt;Arrange the result of step 1 into a square of text (If the string length is not a square integer the last line will not be as long as the rest of the square)&lt;/li&gt;&lt;li&gt;Create a sentence in which the &quot;words&quot; are the columns of the squareHere is my solution:&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;clojure.string :as s&amp;#93;&amp;#41;

&amp;#40;defn crypto-square&amp;#91;s&amp;#93;
  &amp;#40;let&amp;#91;ss &amp;#40;-&amp;gt; s s/lower-case &amp;#40;s/replace #&amp;quot;&amp;#91;&amp;#94;a-z&amp;#93;&amp;quot; &amp;quot;&amp;quot;&amp;#41;&amp;#41;
       l &amp;#40;-&amp;gt; ss count Math/sqrt Math/ceil int&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;&amp;gt; ss
         &amp;#40;partition l l &amp;#40;repeat &amp;quot;&amp;quot;&amp;#41;&amp;#41;
         &amp;#40;apply map vector&amp;#41;
         &amp;#40;map #&amp;#40;apply str %&amp;#41;&amp;#41;
         &amp;#40;s/join &amp;quot; &amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can give it a try right here: &lt;br /&gt; &lt;div&gt; &lt;fieldset style=&quot;background-color: #f0f0f0;&quot;&gt; &lt;br /&gt; &lt;form&gt; Enter text to encode: &lt;input id=&quot;cryptosquare-input&quot; size=&quot;80&quot; type=&quot;text&quot; value=&quot;A beginning is the time for taking the most delicate care that the balances are correct.&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;script&gt; function myFunction() { var x = document.getElementById(&quot;cryptosquare-input&quot;); var out = practice.funcs.crypto_square(x.value); document.getElementById(&quot;cryptosquare-output&quot;).innerHTML = out; } &lt;/script&gt;&lt;/p&gt;&lt;p&gt;&lt;button onclick=&quot;myFunction()&quot; type=&quot;button&quot;&gt;Convert!&lt;/button&gt; &lt;br /&gt; Result:&lt;br /&gt; &lt;div id=&quot;cryptosquare-output&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/fieldset&gt; &lt;br /&gt; &lt;script src=&quot;../../js/cljpractice.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;Commentary:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;This solution makes heavy use of threading macros (&lt;a href='https://clojuredocs.org/clojure.core/-%3E'&gt;-&gt;&lt;/a&gt;is called &quot;Thread first&quot; and &lt;a href='https://clojuredocs.org/clojure.core/-%3E%3E'&gt;-&gt;&gt;&lt;/a&gt; is called &quot;Thread last&quot;). These are great for assembling computation pipelines. These macros take the item after the arrow and repeatedly insert the argument into the next form in the pipeline, carrying forward the result into each successive form. The &quot;first&quot; and &quot;last&quot; refer to where in the succeeding form the new argument goes (first goes after the function name in the form, last goes in the last position in front of the last parens).&lt;/li&gt;&lt;li&gt;The &lt;a href='https://clojuredocs.org/clojure.core/partition'&gt;partition&lt;/a&gt; function creates partitions from a sequence with a specified chunk and step size. A final default argument is used to pad the last partition when the sequence cannot be equally subdivided.&lt;/li&gt;&lt;li&gt;The default padding argument to partition along with the repeat function make ensuring that the string was square trivial. Any missing characters in a non-square string are filled in by padding with empty strings.&lt;/li&gt;&lt;li&gt;The apply method (which I use in several more of these examples) &quot;applies&quot; a function to a sequence by inserting the function in the first position of the sequence and evaluates the new sequence as if it were a list.&lt;/li&gt;&lt;li&gt;A key takeaway in this example is that threading computations as shown really only works with immutability and side-effect free functions. Were either of these properties missing, there are no guarantees regarding your computations and assembling these sorts of pipelines are impossible.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;problem&amp;#95;2:&amp;#95;kindergarten&amp;#95;garden&quot;&gt;Problem 2: Kindergarten Garden&lt;/h3&gt;&lt;p&gt;In this problem, described &lt;a href='https://github.com/trikitrok/MyExercismExercises/blob/master/clojure/kindergarten-garden/README.md'&gt;here&lt;/a&gt;  and solved &lt;a href='http://garajeando.blogspot.com/2015/05/exercism-kindergarten-garden-in-clojure.html'&gt;here&lt;/a&gt;,   two rows of plants are assigned to a group of students who are sorted alphabetically by name. Each student gets a block of plants from left to right (two each in the front row and two each in the back). Depending on the letters in the diagram, you are to determine which kind of plants each student has.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;Solution 1
&amp;#40;defn char-&amp;gt;plant&amp;#91;s&amp;#93;
  &amp;#40;map #&amp;#40;case %
         \V &amp;quot;Violets&amp;quot;
         \R &amp;quot;Radishes&amp;quot;
         \C &amp;quot;Clover&amp;quot;
         \G &amp;quot;Grass&amp;quot;&amp;#41; s&amp;#41;&amp;#41;

&amp;#40;defn kinder&amp;#91;names rows&amp;#93;
  &amp;#40;apply merge-with concat
         &amp;#40;map
           #&amp;#40;zipmap &amp;#40;sort names&amp;#41; &amp;#40;partition 2 %&amp;#41;&amp;#41;
           &amp;#40;map char-&amp;gt;plant &amp;#40;s/split-lines rows&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

;Solution 2
&amp;#40;defn kinder-thread-last&amp;#91;names rows&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; rows
       &amp;#40;s/split-lines&amp;#41;
       &amp;#40;map #&amp;#40;map { \V &amp;quot;Violets&amp;quot; \R &amp;quot;Radishes&amp;quot; \C &amp;quot;Clover&amp;quot; \G &amp;quot;Grass&amp;quot; } %&amp;#41;&amp;#41;
       &amp;#40;map #&amp;#40;zipmap &amp;#40;sort names&amp;#41; &amp;#40;partition 2 %&amp;#41;&amp;#41;&amp;#41;
       &amp;#40;apply merge-with concat&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Results:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def ch &amp;#91;&amp;quot;Alice&amp;quot; &amp;quot;Bob&amp;quot; &amp;quot;Charlie&amp;quot; &amp;quot;David&amp;quot; &amp;quot;Eve&amp;quot; &amp;quot;Fred&amp;quot; &amp;quot;Ginny&amp;quot; &amp;quot;Harriet&amp;quot; &amp;quot;Ileana&amp;quot; &amp;quot;Joseph&amp;quot; &amp;quot;Kincaid&amp;quot; &amp;quot;Larry&amp;quot;&amp;#93;&amp;#41;
&amp;#40;def rows &amp;quot;VRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV&amp;quot;&amp;#41;
&amp;#40;prn &amp;#40;&amp;#40;kinder-thread-last ch rows&amp;#41; &amp;quot;David&amp;quot;&amp;#41;&amp;#41;
;prints &amp;#40;&amp;quot;Radishes&amp;quot; &amp;quot;Violets&amp;quot; &amp;quot;Clover&amp;quot; &amp;quot;Radishes&amp;quot;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Commentary:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;I provided two solutions. My first did not use threading macros. I think the thread last version (#2) is much easier to read. It is quite easy to see the sequence of steps being followed.&lt;/li&gt;&lt;li&gt;Another important thing to note is how I mapped the characters in the gardens to plants. I can use a case statement like what is done in the char-&gt;plant function. However, a simpler and more concise solution is to simply use a map. Clojure maps (and vectors and sets) are not just data structures, but are also functions. This may seem weird at first, but it actually makes sense. A map (in any language) is simply a discrete 1:1 function that maps keys to values. A vector is a function of its indices and a set is a function of its contents. Using this knowledge, I just mapped the characters in the strings using the map of characters to plant names as an inlined function.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;problem&amp;#95;3:&amp;#95;treasure&amp;#95;hunt&quot;&gt;Problem 3: Treasure Hunt&lt;/h3&gt;&lt;p&gt;In the treasure hunt problem described &lt;a href='http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html'&gt;here&lt;/a&gt;  you are given a 2D array of two digit map coordinates. From a starting coordinate that I am assuming comes from a pirate, you look up each successive coordinate on the map by using the first and second digits of the current coordinate as the row and column on the map. Once a coordinate maps to itself, start digging, you are done.&lt;/p&gt;&lt;p&gt;Here is my solution:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn map-step&amp;#91;m clue&amp;#93;
  &amp;#40;let &amp;#91;n &amp;#40;get-in m &amp;#91;&amp;#40;dec &amp;#40;quot clue 10&amp;#41;&amp;#41; &amp;#40;dec &amp;#40;rem clue 10&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;when &amp;#40;not= n clue&amp;#41; n&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn treasure-hunt &amp;#91;m start&amp;#93;
  &amp;#40;take-while identity &amp;#40;iterate &amp;#40;partial map-step m&amp;#41; start&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here it is in action: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def treasure-map &amp;#91;&amp;#91;34 21 32 41 25&amp;#93;
                   &amp;#91;14 42 43 14 31&amp;#93;
                   &amp;#91;54 45 52 42 23&amp;#93;
                   &amp;#91;33 15 51 31 35&amp;#93;
                   &amp;#91;21 52 33 13 23&amp;#93;&amp;#93;&amp;#41;

&amp;#40;prn &amp;#40;treasure-hunt treasure-map 11&amp;#41;&amp;#41;
;prints &amp;#40;11 34 42 15 25 31 54 13 32 45 35 23 43 51 21 14 41 33 52&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Commentary:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The map-step function simply computes the next step in the map. What's beautiful about this method is that it very naturally uses the Clojure get-in function to solve the problem. get-in is a Clojure function that allows you to drill down into a nested data structure by providing a vector of successive indices. Conveniently, our two-digit coordinates can be split into a vector for get-in access. Note that I do need to decrement the coordinates to make them 0 indexed.&lt;/li&gt;&lt;li&gt;The only additional logic required was the exit criteria. I compared the looked up coordinate to the input. If they are different, I return the update. Otherwise, nil is returned.&lt;/li&gt;&lt;li&gt;The treasure-hunt is where the real awesomeness happens. I can create a &lt;a href='https://clojuredocs.org/clojure.core/partial'&gt;partial&lt;/a&gt; map-step function by filling in the first argument of the function with a treasure map. I now have a function that  takes an [x y] coordinate and returns an [x y] coordinate. I want to repeatedly do this until I return nil.   Sounds like a perfect candidate for Clojure's &lt;a href='https://clojuredocs.org/clojure.core/iterate'&gt;iterate&lt;/a&gt; function.   iterate takes a function and an initial condition and repeatedly   returns the result of the applied function and reapplies that result to itself. To determine a stopping condition,    I take results while the function satisfies the &lt;a href='https://clojuredocs.org/clojure.core/identity'&gt;identity&lt;/a&gt; function.    Identity is a clever method that simply returns what is passed to it. In Clojure, anything not false or nil will pass logical truth tests (this is called truthiness), so as long as my function returns new coordinates I will take coordinates from it.&lt;/li&gt;&lt;li&gt;It is quite common in Clojure to store your state in a structure and do a computation that returns a new state that is similarly structured to the original. Whenever you do this, iterate may be a great option. You can take a certain number of items from the iterated function or continue until a stop condition is met.&lt;/li&gt;&lt;li&gt;Finally, this problem really is one of data navigation, and that is something Clojure excels at. Clojure is all about nested heterogeneous data structures and has many methods to safely inspect, update, and transform them. Furthermore, Clojure's semantics for truthiness and handling of nil makes what would normally be exceptional behavior simple to handle.&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;problem&amp;#95;4:&amp;#95;queen&amp;#95;attack&quot;&gt;Problem 4: Queen Attack&lt;/h3&gt;&lt;p&gt;The basic problem is this:  Given two queens on a chessboard, are they in an &quot;attack&quot; configuration.  In other words, are they in a shared column, row, or diagonal. Here's a &lt;a href='http://garajeando.blogspot.com/2015/05/exercism-queen-attack-in-clojure.html'&gt;solution&lt;/a&gt; from my original browsing exercise. As presented &lt;a href='http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html'&gt;here&lt;/a&gt;,  the problem is to encode an 8x8 board using different characters. I took a different approach and simply used the coordinates of the pieces to determine if they were visible to each other.&lt;/p&gt;&lt;p&gt;Here is my complete solution:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn queen-attack?&amp;#91;w b&amp;#93;
  &amp;#40;let &amp;#91;diff &amp;#40;map - w b&amp;#41;
        zs &amp;#40;&amp;#40;juxt first second #&amp;#40;reduce - %&amp;#41; #&amp;#40;reduce + %&amp;#41;&amp;#41; diff&amp;#41;&amp;#93;
    &amp;#40;true? &amp;#40;some zero? zs&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are a few invocations of the function with results in comments:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;prn &amp;#40;queen-attack? &amp;#91;2 3&amp;#93; &amp;#91;2 10&amp;#93;&amp;#41;&amp;#41; ;true - same row
&amp;#40;prn &amp;#40;queen-attack? &amp;#91;9 10&amp;#93; &amp;#91;2 10&amp;#93;&amp;#41;&amp;#41; ;true - same column
&amp;#40;prn &amp;#40;queen-attack? &amp;#91;4 3&amp;#93; &amp;#91;2 10&amp;#93;&amp;#41;&amp;#41; ;false
&amp;#40;prn &amp;#40;queen-attack? &amp;#91;7 12&amp;#93; &amp;#91;5 10&amp;#93;&amp;#41;&amp;#41; ;true - same diagonal
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Commentary:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The most important thing to note in this solution is that being on the same row, column, or diagonal reduces to simple difference checks on the piece indices. A zero difference in the row or column means you are on the same row or column. If the sum or difference of the row and column change is 0 you are on the same diagonal. If this last rule doesn't make sense, stop for a second and think about it. To move diagonally, you must move the same amount up or down as you do left or right. So, the sum or difference (depending on direction) will be 0.&lt;/li&gt;&lt;li&gt;I use &lt;a href='http://fn-code.blogspot.com/2015/03/using-juxt-to-compute-signed-angular.html'&gt;juxt&lt;/a&gt; to compute the 4 potential zeroes. I also discuss juxt at length in this post.&lt;/li&gt;&lt;li&gt;&lt;a href='https://clojuredocs.org/clojure.core/some'&gt;some&lt;/a&gt; &lt;a href='https://clojuredocs.org/clojure.core/zero_q'&gt;zero?&lt;/a&gt; checks if any zeroes exist. If any exist, the result is true. It none exist the result is nil. Therefore, I call true? to covert a nil to false. Note that Clojure uses &quot;truthiness&quot; when doing logic checks (i.e. nil and false return false, everything else returns true). So, I could just as easily drop the true? check if I felt like it.&lt;/li&gt;&lt;li&gt;Probably the biggest takeaway from this problem is the difference between a standard OOP solution vs. an FP solution.In OOP the natural approach to the problem would be to start with a  nice class hierarchy such as a Board (which would contain 64 Squares). You would probably have a ChessPiece class which you'd extend into Pawn, Rook, Knight, Bishop, Queen, and King classes. At this point you'd probably determine some basic methods such as move and attack which would allow you to finally approach solving the problem. In FP, you generally think directly in terms of what you are trying to do since your domain model is just data. Had I been asked to solve the problem for all chess pieces in Clojure, I'd probably just create a &lt;a href='https://clojuredocs.org/clojure.core/defmulti'&gt;multimethod&lt;/a&gt; that dispatches on the attacker type (:pawn, :rook, :knight, :bishop, :queen, or :king). Each resulting &lt;a href='https://clojuredocs.org/clojure.core/defmethod'&gt;defmethod&lt;/a&gt; would be as concise as the above function.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;In a few short lines, I was able to solve 4 programming puzzlers using Clojure. While none of the problems were particularly hard, each illustrated several interesting functions and aspects of Clojure programming that I thought were worth pointing out. In particular, Clojure excels at representing, manipulating, and navigating data as simple structures. I find it much easier to model the data directly using Clojure's data structures than developing elaborate class hierarchies for each problem. This way of thinking allows you to jump right into solving your problem without having to spend a lot of time figuring out how to represent the data.&lt;/p&gt;&lt;p&gt;If you liked this page or learned anything from it, please tweet the link,follow me on Twitter, and/or follow this blog. Your support and interest is the fuel that drives the effort.&lt;/p&gt;
</description>
<pubDate>
Wed, 27 May 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-05-15-fpfirehose/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-05-15-fpfirehose/
</link>
<title>
Functional Programming from the Fire Hose
</title>
<description>
 &lt;p&gt;Earlier this year I gave a presentation at work entitled &quot;Functional Programming (FP) from the Fire Hose.&quot;  My goal was to present, to a mostly OOP audience, some of the basics of FP while also providing examples that show  that FP isn't just academic. You can't sell people on FP with concepts alone. People's eyes just glaze over and roll  back into their heads when you start talking functional concepts like first class and higher order functions,  immutability, statelessness, referential transparency, homoiconicity, and the like (I won't even say the M-word).  With that in mind, I tried to go fast on FP and show several clear examples that demonstrate FP in action, even at a  very small scale.  &lt;/p&gt;&lt;p&gt;In my presentation, I do (or attempt to do) the following:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Explain FP in 5 minutes to an OOP audience&lt;/li&gt;&lt;li&gt;Explain why functions are important using collections as the context.&lt;/li&gt;&lt;li&gt;Explain that first class functions are a necessary but not sufficient condition for FP. You also must have immutability.&lt;/li&gt;&lt;li&gt;Solve a small problem in both FP and OOP style. The examples, written in Clojure and Java, respectively,show the simplicity and power of FP vs. traditional OOP.&lt;/li&gt;&lt;li&gt;Demonstrate how you can write functional code in a stateful application using Clojure concurrency primitives.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Here's the video and links to additional resources. I hope you enjoy.  &lt;/p&gt;&lt;p&gt;&lt;iframe allowfullscreen=&quot;&quot; class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-src=&quot;https://i.ytimg.com/vi/Ie2dinyRDu0/0.jpg&quot; frameborder=&quot;0&quot; height=&quot;380&quot; src=&quot;https://www.youtube.com/embed/Ie2dinyRDu0?feature=player_embedded&quot; width=&quot;480&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;&lt;p&gt;The slides are &lt;a href='http://markbastian.github.io/fp-firehose/fp-firehose.html#/'&gt;here&lt;/a&gt;,  and the accompanying repo and demo are &lt;a href='https://github.com/markbastian/fp-firehose'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If you liked this page or learned anything from it, please tweet the link,follow me on Twitter, and/or follow this blog.  Your support and interest is the fuel that drives the effort.&lt;/p&gt;
</description>
<pubDate>
Fri, 15 May 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-04-28-predator-prey/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-04-28-predator-prey/
</link>
<title>
Predator-Prey Modeling in Clojure
</title>
<description>
 &lt;h2 id=&quot;introduction&amp;#95;to&amp;#95;predator-prey&amp;#95;systems&quot;&gt;Introduction to Predator-Prey Systems&lt;/h2&gt;&lt;p&gt;In this edition of the blog, I'll discuss how you can use Clojure to solve a system of nonlinear differential equations.  he particular system I'll be solving is the Predator-Prey or Lotka-Volterra Model, which you can read all about right  &lt;a href='https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations'&gt;here&lt;/a&gt;. The basic concept is that you are modeling a population of predators and prey (e.g. Foxes and Rabbits, which we'll use here). How the two populations change over time can be modeled like so:&lt;/p&gt;&lt;p&gt;&amp;#92;({dR\over dt} = \alpha R - \beta R F&amp;#92;)&lt;/p&gt;&lt;p&gt;&amp;#92;({dF\over dt} = - \gamma F + \delta R F&amp;#92;)&lt;/p&gt;&lt;p&gt;These are differential equations, meaning equations that model the change of the system as a function of its state as opposed to an equation that allows you to directly compute the system's state.&lt;/p&gt;&lt;p&gt;The variables and parameters are:&lt;/p&gt;&lt;p&gt;&amp;#92;({dR\over dt}&amp;#92;): The rate of change of the rabbit population over time.&lt;/p&gt;&lt;p&gt;&amp;#92;({dF\over dt}&amp;#92;): The rate of change of the fox population over time.&lt;/p&gt;&lt;p&gt;&amp;#92;(R&amp;#92;): Current rabbit population. Note that this is a continuous value. You could have 4.5 rabbits. If this causes you heartburn, think of it as thousands or rabbits in which partial rabbits are still gestating.&lt;/p&gt;&lt;p&gt;&amp;#92;(F&amp;#92;): Current fox population. The same notes apply as in &amp;#40;R&amp;#41;.&lt;/p&gt;&lt;p&gt;&amp;#92;(\alpha&amp;#92;): The reproduction rate of the rabbits. If you look at the equation, a larger &amp;#40;\alpha&amp;#41; will increase the rate of rabbit population growth.&lt;/p&gt;&lt;p&gt;&amp;#92;(\beta&amp;#92;): The predation rate of the rabbits. This value negatively affects the rabbit population as it models the interaction between foxes and rabbits.&lt;/p&gt;&lt;p&gt;&amp;#92;(\gamma&amp;#92;): The death rate of the foxes. This is a negative term as the foxes will die when left to their own devices.&lt;/p&gt;&lt;p&gt;&amp;#92;(\delta&amp;#92;): This models the growth rate of foxes with respect to their interaction with rabbits. Foxes are positively affected when they interact with rabbits because rabbits are their food source.&lt;/p&gt;&lt;h3 id=&quot;method&amp;#95;of&amp;#95;solution&quot;&gt;Method of Solution&lt;/h3&gt;&lt;p&gt;There is no closed-form solution to this problem (i.e. There is no simple pair of equations &amp;#40;F(t)&amp;#41; and &amp;#40;R(t)&amp;#41; that satisfy the governing differential equations described above.). This is often the case in differential equations. Since a closed-form solution does not exist, the problem of determining the populations at any given time must be solved numerically.&lt;/p&gt;&lt;p&gt;Here is a basic overview of how this is done:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Starting with an initial state, compute how the state is changing by plugging the current state into the differential equations.&lt;/li&gt;&lt;li&gt;Multiply the resulting differential values by some small time step and add these scaled values to the initial state.By repeating this process, you can step forward in time and compute the state of your model at any given time. This numerical method is called Euler's method and isn't particularly accurate since the &quot;small time step&quot; in step 2 doesn't account for instantaneous time changes. It is just an approximation. To get better answers, you can compute multiple values of the differential equations and add them together in such a way as to produce a much better solution. This family of solutions is called Runge-Kutta (RK) methods. Read all about them &lt;a href='https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods'&gt;here&lt;/a&gt;. The details of RK methods are beyond the scope of this blog, but one thing to know is that any explicit RK method can be described by what's called a Butcher Tableau (BT). The BT tells how many derivatives are to be computed, at what points they are computed, and how they are averaged to compute a more accurate solution.&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;implementation&amp;#95;in&amp;#95;clojure&quot;&gt;Implementation in Clojure&lt;/h3&gt;&lt;p&gt;In most introductory texts, the &quot;Classic&quot; 4th Order RK Method is described and implemented.  This is simply a single RK method with a specific Butcher Tableau that yields 4th order polynomial accuracy when  computing a solution. I've implemented a general RK solver in Clojure instead. To make my implementation &quot;general,&quot;  I've written the method such that it takes any Butcher Tableau as an argument so you are not limited to the classic  4th order RK method. Note that you can find the entire project on my Github page &lt;a href='https://github.com/markbastian/numerics'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Here's the code for computing a single step in a RK method:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn ki &amp;quot;Compute a single k value for a system of difeqs.&amp;quot;
&amp;#91;f &amp;#91;tn &amp;amp; yn&amp;#93; dt a c k&amp;#93;
&amp;#40;let &amp;#91;dy &amp;#40;map #&amp;#40;&amp;#42; dt &amp;#40;reduce + &amp;#40;map &amp;#42; a %&amp;#41;&amp;#41;&amp;#41; k&amp;#41;&amp;#93;
 &amp;#40;&amp;#40;apply juxt f&amp;#41; &amp;#40;into &amp;#91;&amp;#40;+ tn &amp;#40;&amp;#42; dt c&amp;#41;&amp;#41;&amp;#93; &amp;#40;map + yn dy&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn ks &amp;quot;Compute all of the k values &amp;#40;derivatives&amp;#41; in the step.&amp;quot;
&amp;#91;f ic dt { :keys &amp;#91;a c&amp;#93; }&amp;#93;
&amp;#40;loop &amp;#91;ks &amp;#40;repeat &amp;#40;count f&amp;#41; &amp;#91;&amp;#93;&amp;#41; ai a ci c&amp;#93;
 &amp;#40;if-not &amp;#40;first ci&amp;#41;
   ks
   &amp;#40;recur
     &amp;#40;map conj ks &amp;#40;ki f ic dt &amp;#40;first ai&amp;#41; &amp;#40;first ci&amp;#41; ks&amp;#41;&amp;#41;
     &amp;#40;rest ai&amp;#41;
     &amp;#40;rest ci&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn integrate 
&amp;quot;Perform the numerical integration step by adding the
weighted derivatives to the initial conditions.&amp;quot;
&amp;#91;k &amp;#91;tn &amp;amp; yn&amp;#93; dt b&amp;#93;
&amp;#40;let &amp;#91;deltas &amp;#40;map #&amp;#40;reduce + &amp;#40;map &amp;#42; b %&amp;#41;&amp;#41; k&amp;#41;&amp;#93;
 &amp;#40;into &amp;#91;&amp;#40;+ tn dt&amp;#41;&amp;#93; &amp;#40;map #&amp;#40;-&amp;gt; %1 &amp;#40;&amp;#42; dt&amp;#41; &amp;#40;+ %2&amp;#41;&amp;#41; deltas yn&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn rk-step &amp;quot;Take a single step forward by dt&amp;quot;
&amp;#91;f ic dt { :keys &amp;#91;b&amp;#93; :as tableau}&amp;#93;
&amp;#40;integrate &amp;#40;ks f ic dt tableau&amp;#41; ic dt b&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I don't really expect most readers to dive right in and understand this code, since it requires an understanding of both numerical methods and Clojure. However, there are a few things I'd like to point out:  &lt;/p&gt;&lt;ul&gt;&lt;li&gt;The solution is implemented in 25 lines of code and works with a variety of Butcher Tableaus for varying accuracy. Having implemented this before in different languages (C++, Scala) I can say that this is easily the shortest and most concise version I've done yet. Although brevity isn't an end unto itself, I really like having a full implementation of an algorithm that fits in a single window since it makes it much easier for me to see everything that's going on.&lt;/li&gt;&lt;li&gt;This project makes heavy use of destructuring. For this unfamiliar with this, it is a Clojure language feature for quickly extracting elements of data structures. Read more about destructuring &lt;a href='http://blog.jayfields.com/2010/07/clojure-destructuring.html'&gt;here&lt;/a&gt; and &lt;a href='https://gist.github.com/john2x/e1dca953548bfdfb9844'&gt;here&lt;/a&gt;. When you first start using it, it seems very weird. Once you get used to it, you can't live without it.&lt;/li&gt;&lt;li&gt;The way explicit RK methods work, you recursively build up your k matrix (k is a set of derivative values computed using previous values) at each step. This provides a great example of how to use Clojure's loop-recur pattern.&lt;/li&gt;&lt;li&gt;One interesting challenge I had with this problem was how to properly accumulate the k matrices (derivatives). Without going into the details, I had to construct a set of growing column vectors with each recur. To make these grow I used map conj to add the new values onto the earlier vectors. The problem was that on the initial pass I needed empty vectors to conj into. To solve this problem I initialized my k column vectors with this form: (repeat (count f) []), where f is my system of differential equations. Once I figured this out it worked like a charm. Often this is the case in Clojure - You spend more time thinking about your solution than writing it.&lt;/li&gt;&lt;li&gt;Once again, I got to use the awesome juxt function. This time, I used it to turn my set of equations into a single function that returned a vector of results. &lt;/li&gt;&lt;/ul&gt;&lt;p&gt; To compute the solution, the rk-step function is called with the equations to be solved, the initial conditions, the desired time step, and the Butcher Tableau. Here is how the BT for the classic 4th order RK method is defined:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def classic-fourth-order
{ :c &amp;#91;0 0.5 0.5 1.0&amp;#93;
:a &amp;#91;&amp;#91;&amp;#93;
    &amp;#91;0.5&amp;#93;
    &amp;#91;0.0 0.5&amp;#93;
    &amp;#91;0.0 0.0 1.0&amp;#93;&amp;#93;
:b &amp;#91;&amp;#40;/ 1.0 6.0&amp;#41; &amp;#40;/ 1.0 3.0&amp;#41; &amp;#40;/ 1.0 3.0&amp;#41; &amp;#40;/ 1.0 6.0&amp;#41;&amp;#93; }&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I've defined a variety of common BTs in &lt;a href='https://github.com/markbastian/numerics/blob/master/src/cljc/numerics/tableaus.cljc'&gt;this namespace&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;And here is how I would use the code:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def dt 0.1&amp;#41;
&amp;#40;def ic &amp;#91;0 4 1&amp;#93;&amp;#41;
&amp;#40;defn dr &amp;#91;&amp;#91;&amp;#95; R F&amp;#93;&amp;#93; &amp;#40;- &amp;#40;&amp;#42; 2.0 R&amp;#41; &amp;#40;&amp;#42; 1.2 R F&amp;#41;&amp;#41;&amp;#41;
&amp;#40;defn df &amp;#91;&amp;#91;&amp;#95; R F&amp;#93;&amp;#93; &amp;#40;- &amp;#40;&amp;#42; 0.9 R F&amp;#41; F&amp;#41;&amp;#41;

&amp;#40;def steps &amp;#40;take 100 &amp;#40;iterate #&amp;#40;rk/rk-step &amp;#91;dr df&amp;#93; % dt tableaus/classic-fourth-order&amp;#41; ic&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that you've seen the code, let's take a look at some results.&lt;/p&gt;&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;&lt;p&gt;One way that differential equations can be analyzed is with a direction field. This works well for a system of 2 equations. You plot the derivatives as vectors at each point in their state space to see how the system changes at any given state. In this case, I made each arrow a single length, so we are only looking at direction of change, not magnitude. Below, I show an example of a direction field using the dr and df functions from the above code example. You can see that there is an equilibrium point around which the system spirals. At this point, there are a perfect number of foxes and rabbits such that the populations remain constant. The spiral behavior should be intuitive. If there are a small number of foxes, the rabbit population will grow. This results in more available food, so the fox population will then grow. As the fox population grows there are more predators and the rabbit population is hunted down. As the rabbit population decreases, food becomes scarce and the foxes starve to death. Finally, we are back where we started (a small number of foxes, allowing the rabbit population to rise again).&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/df.png&quot; alt=&quot;alt text&quot; title=&quot;Direction Field&quot; /&gt;&lt;/p&gt;&lt;p&gt;The same trend can be shown in time (see below). This shows how the rabbit population leads the fox population. When there are a lot of rabbits, there will soon be a lot of foxes since there is a lot of food. Conversely, when there are few rabbits, the fox population will soon die off.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/pp.png&quot; alt=&quot;alt text&quot; title=&quot;Phase Space Plot&quot; /&gt;&lt;/p&gt;&lt;p&gt;Note that these charts were generated using JFreeChart.&lt;/p&gt;&lt;h3 id=&quot;interactive&amp;#95;demo&quot;&gt;Interactive Demo&lt;/h3&gt;&lt;p&gt;Since this is Clojure, I would be doing it all wrong if I just targeted the JVM. Using the excellent cljx lien plugin this code cross-compiles to ClojureScript as well so that it works in the browser. Here is an interactive demo in which you create a &lt;a href='https://en.wikipedia.org/wiki/Phase_space'&gt;phase space plot&lt;/a&gt; by adjust the initial populations of foxes and rabbits as well as the parameters affecting population growth and interaction. This plot shows what happens when you pick an initial location and parameters in a direction field and march forward in time. It shows all possible states for those particular initial conditions with the given equations.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;container&quot;&gt; &lt;canvas height=&quot;400&quot; id=&quot;rkCanvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Initial Prey Population&lt;/label&gt; &lt;input id=&quot;prey-population-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Initial Predator Population&lt;/label&gt; &lt;input id=&quot;predator-population-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Reproduction Rate&lt;/label&gt; &lt;input id=&quot;reproduction-rate-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Predation Rate&lt;/label&gt; &lt;input id=&quot;predation-rate-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Growth Rate&lt;/label&gt; &lt;input id=&quot;growth-rate-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label style=&quot;display: inline-block; width: 200px;&quot;&gt;Death Rate&lt;/label&gt; &lt;input id=&quot;death-rate-slider&quot; max=&quot;500&quot; min=&quot;0&quot; step=&quot;1&quot; type=&quot;range&quot; /&gt; &lt;/div&gt; &lt;script src=&quot;../../js/rk.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Clojure is a great language for numerical analysis. The fact that it is functional makes it very intuitive to code up mathematical relations that have the same functional underpinnings.&lt;/p&gt;&lt;p&gt;Finally, RK methods, including this particular implementation, aren't just for research problems like what was presented here. If you were to write a game engine with a physics element, this would be a perfect code library for computing your force interactions at every frame. Just compute the time delta between frames for your time step and use Newton's Second Law as your governing equation. The dual JVM/JavaScript implementation also makes it easy for your simulation to run in a desktop client or in the browser.&lt;/p&gt;&lt;h2 id=&quot;afterword&quot;&gt;Afterword&lt;/h2&gt;&lt;p&gt;If you liked this page or learned anything from it, please tweet the link and/or follow me on Twitter. Your support and interest is the fuel that drives the effort.&lt;/p&gt; 
</description>
<pubDate>
Tue, 28 Apr 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-04-11-mazes/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-04-11-mazes/
</link>
<title>
A-maze-ing Mazes with Clojure
</title>
<description>
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;&lt;p&gt;Mazes can be pretty fun. Children love them. Add a dungeon theme (e.g. monsters, loot, and a dragon boss) and most computer programming adults like them, too.&lt;/p&gt;&lt;p&gt;In this post, I'll show you how to make some mazes in Clojure/ClojureScript. Feel free to print some off for your next trip with your kids or adapt this code to your next campaign if you are a DM.&lt;/p&gt;&lt;p&gt;The techniques I'll be covering are Prim's algorithm and Depth-First Search with Backtracking. Afterwords, I'll show you the code and discuss some interesting points.&lt;/p&gt;&lt;p&gt;Here are the algorithms:&lt;/p&gt;&lt;h3 id=&quot;prim's&amp;#95;algorithm&quot;&gt;Prim's Algorithm&lt;/h3&gt;&lt;p&gt;This algorithm will produce mazes with a fair amount of branching and not a lot of long corridors. Here are the steps in the algorithm:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Mark all cells in your maze as undiscovered.&lt;/li&gt;&lt;li&gt;Select a start cell and mark it as visited.&lt;/li&gt;&lt;li&gt;Mark all neighbors of the start cell as frontier cells.&lt;/li&gt;&lt;li&gt;Randomly select a cell from the frontier as your next cell.&lt;/li&gt;&lt;li&gt;Add it to the maze.&lt;/li&gt;&lt;li&gt;Add any neighbors of the selected cell that are undiscovered to the frontier.&lt;/li&gt;&lt;li&gt;Connect the selected cell to the maze by randomly selecting an adjacent cell that is already in the maze and mark the two cells as connected.&lt;/li&gt;&lt;li&gt;If the frontier is not empty, goto 4. Otherwise, your maze is complete.&lt;/li&gt;&lt;li&gt;You can optionally mark a cell as the end, but this is just a convenience for knowing when you can leave the dungeon. The maze is fully connected so the endpoint is arbitrary.&lt;/li&gt;&lt;/ol&gt;&lt;h3 id=&quot;depth-first&amp;#95;search&amp;#95;with&amp;#95;backtracking&quot;&gt;Depth-First Search with Backtracking&lt;/h3&gt;&lt;p&gt;DFS will produce longer corridors since it continues to move forward until it is blocked. Here are the steps in the algorithm:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Select a cell, mark it as in the maze, and put it on the path stack.&lt;/li&gt;&lt;li&gt;Randomly select an unvisited neighbor of the current cell, connect it to the previous cell, and put the new cell on the path stack. Since we are always stepping forward to a different cell we are going to make longer paths. This is the &quot;Depth-First&quot; part of the algorithm.&lt;/li&gt;&lt;li&gt;If the current cell has unvisited neighbors, goto 2. Otherwise, pop the top off the path stack, make the new top of the stack the current cell, and goto 2 (This is the &quot;backtracking&quot; part of the algorithm). Repeat until every cell has been visited.&lt;/li&gt;&lt;li&gt;As with Prim's algorithm, you can choose an exit if desired, but this is arbitrary.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;You can read more about these &lt;a href='https://en.wikipedia.org/wiki/Maze_generation_algorithm'&gt;here&lt;/a&gt; and &lt;a href='http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap.html'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Without further ado, here are mazes generated using these algorithms. There is a reset button below the second maze to recreate them if you want.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Maze generated using Prim's algorithm&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;canvas height=&quot;400&quot; id=&quot;primCanvas&quot; style=&quot;border: 1px solid rgb(0, 0, 0);&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Maze generated using Depth-First Search with Backtracking&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;canvas height=&quot;400&quot; id=&quot;dfbCanvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;&lt;div&gt; &lt;button id=&quot;regenMazes&quot; type=&quot;button&quot;&gt;Reset&lt;/button&gt; &lt;/dev&gt; &lt;script src=&quot;../../js/mazegen.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;h3 id=&quot;the&amp;#95;source&quot;&gt;The Source&lt;/h3&gt;&lt;p&gt;Here is the complete implementation of the maze generators. Less than 50 lines! Despite being such a small namespace, it does a lot. Continue on past the code to see my comments and observations regarding this exercise.&lt;/p&gt;&lt;p&gt;Note that I did not include the source for rendering the mazes onto the HTML canvas. You can see that as well as a standalone Java Swing version of the code by checking out the complete project here.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns mazegen.rules&amp;#41;

&amp;#40;defn create-empty
  &amp;quot;Create an empty rectangular maze.&amp;quot;
  &amp;#91;rows cols&amp;#93;
  &amp;#40;vec &amp;#40;take rows &amp;#40;repeat &amp;#40;vec &amp;#40;take cols &amp;#40;repeat #{}&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn neighbors
  &amp;quot;Compute the neighbors of a given coordinate.&amp;quot;
  &amp;#91;maze &amp;#91;i j&amp;#93;&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; &amp;#40;map vector
            &amp;#40;&amp;#40;juxt inc identity dec identity&amp;#41; i&amp;#41;
            &amp;#40;&amp;#40;juxt identity inc identity dec&amp;#41; j&amp;#41;&amp;#41;
       &amp;#40;filter #&amp;#40;get-in maze %&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn open-wall
  &amp;quot;Create pathways between the src and dst coords of the maze.&amp;quot;
  &amp;#91;maze src dst&amp;#93;
  &amp;#40;-&amp;gt; maze
      &amp;#40;update-in src conj dst&amp;#41;
      &amp;#40;update-in dst conj src&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn prim-gen
  &amp;quot;Create a maze using Prim's method.&amp;quot;
  &amp;#91;empty-maze start end&amp;#93;
  &amp;#40;loop &amp;#91;maze &amp;#40;update-in empty-maze start conj :start&amp;#41;
         frontier &amp;#40;into #{} &amp;#40;neighbors maze start&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;empty? frontier&amp;#41;
      &amp;#40;update-in maze end conj :end&amp;#41;
      &amp;#40;let &amp;#91;dst &amp;#40;rand-nth &amp;#40;vec frontier&amp;#41;&amp;#41;
            n &amp;#40;neighbors maze dst&amp;#41;
            { f true s false } &amp;#40;group-by #&amp;#40;empty? &amp;#40;get-in maze %&amp;#41;&amp;#41; n&amp;#41;&amp;#93;
        &amp;#40;recur &amp;#40;open-wall maze &amp;#40;rand-nth s&amp;#41; dst&amp;#41;
               &amp;#40;into &amp;#40;disj frontier dst&amp;#41; f&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn depth-first-gen
  &amp;quot;Create a maze using a depth-first recursive search with backtracking.&amp;quot;
  &amp;#91;empty-maze start end&amp;#93;
  &amp;#40;loop &amp;#91;maze &amp;#40;update-in empty-maze start conj :start&amp;#41;
         visited &amp;#91;start&amp;#93;&amp;#93;
    &amp;#40;if &amp;#40;empty? visited&amp;#41;
      &amp;#40;update-in maze end conj :end&amp;#41;
      &amp;#40;let &amp;#91;n &amp;#40;neighbors maze &amp;#40;first visited&amp;#41;&amp;#41;
            f &amp;#40;filter #&amp;#40;empty? &amp;#40;get-in maze %&amp;#41;&amp;#41; n&amp;#41;&amp;#93;
        &amp;#40;if &amp;#40;empty? f&amp;#41;
          &amp;#40;recur maze &amp;#40;rest visited&amp;#41;&amp;#41;
          &amp;#40;let &amp;#91;dst &amp;#40;rand-nth &amp;#40;vec f&amp;#41;&amp;#41;&amp;#93;
            &amp;#40;recur &amp;#40;open-wall maze &amp;#40;first visited&amp;#41; dst&amp;#41;
                   &amp;#40;conj visited dst&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;comments,&amp;#95;observations,&amp;#95;lessons&amp;#95;learned&quot;&gt;Comments, Observations, Lessons Learned&lt;/h3&gt;&lt;p&gt;Here are some points that you might find interesting from this exercise:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The Data Model: In Java you would likely have a Maze class with Cells or some similar type hierarchy. In Clojure, you generally think about the data and model your domain in terms of simple data structures (vectors, maps, and sets). As the program grows, the data can flexibly grow with it. I modeled the maze as a 2D vector of sets. Each set represents a cell that contains links to other cells as well as any other data that I want to throw into it. In this case, I add :start and :end keywords to cells to represent entry and exit points. Had I used an object hierarchy, I would have to have made some decisions a priori regarding what can and can't go into a Cell. Would a cell have a start, be a start, or something else? Suppose I wanted to add a dragon at the exit that I had to fight to complete the maze. In Object Land, I now have to go back and redesign my type hierarchy to accommodate such a thing. In Clojure, I simply add a :dragon to the current cell set. If I decide I want something more hierarchical, I could easily change my sets in each cell to a map, or even add a map entry to the set (Maybe the dragon isn't just a keyword - Perhaps I also need to store its hit points or other attriubutes). Alternatively, I could have represented the maze as a map of [x y] coordinates as keys and another nested data structure as values.&lt;/li&gt;&lt;li&gt;The neighbors function has some awesomeness that needs some explaining. First, see that I am using the juxt function(as explained &lt;a href='../2015-03-31-juxt/'&gt;here&lt;/a&gt; and &lt;a href='../2015-03-30-life/'&gt;here&lt;/a&gt;) to determine my neighbor's coordinates. However, I may get coordinates like [-1 0] that are off the maze (the maze has minimum coords of [0 0] and maximum of [(dec dim) (dec dim)]). Rather than checking if the coordinate is in the grid or not, I attempt to access it using the get-in function. The great thing about get-in is that it allows you to safely drill down into nested data structures. If the element is missing or the path you are navigating is bad, it returns nil (You can also provide an optional default value). Contrast this to Java or Scala, where you must be very careful about navigating into nested data structures (e.g. maps of maps). One wrong get and you will get a NullPointerException. The filter method is called on the results of calling get-in over all of the coordinates in the maze. Filter will drop all of the nils that are returned, so anything off the maze goes away.&lt;/li&gt;&lt;li&gt;The neighbors and open-wall methods make use of threading macros (-&gt; is thread first) and (-&gt;&gt; is thread last). These deserve a post of their own, but the short explanation is that they take a value and feed it through a succession of functions. As each function is called, the result is passed to the next function. This allows you to create processing pipelines. The first vs. last distinction has to do with where the thing being threaded goes in the next function (first or last position). As I said, this is worthy of its own post and I won't go into a ton of detail here.&lt;/li&gt;&lt;li&gt;Finally, we don't goto in Clojure. Any self-respecting language would use recursion instead. Clojure has a pattern for recursion called loop-recur. Loop is the first line of the pattern and initializes a set of items to be iterated upon. This is typically followed by an if or other branching statement that has a stop condition and a recursion condition. If the stop condition is met, you return. If the recur condition is met, you update the items being iterated upon. In my examples, I used recur to track the maze, the active cell, the frontier, and similar items. One important point about loop-recur is that recur must be in the tail position of the calculation (the last thing being calculated before looping). By doing so, the construct is transformed under the covers so that the stack does not grow and you are just doing a simple loop.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There is more that can be gleaned from this short application, but I think this is good for now. It is easy to see, however, that Clojure is a very powerful and expressive language.&lt;/p&gt;&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;&lt;p&gt;Mazes are an interesting problem that can demonstrate a lot of features of functional programming. In this case, the functional language of choice was Clojure. Clojure's powerful data modeling aspects combined with its expressiveness made it easy to create a flexible and concise solution to this problem. If you liked this page or learned anything from it, please tweet the link and/or follow me on Twitter. Your support and interest is the fuel that drives the effort.&lt;/p&gt;
</description>
<pubDate>
Sat, 11 Apr 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-03-31-juxt/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-03-31-juxt/
</link>
<title>
Using juxt to Compute Signed Angular Distances
</title>
<description>
&lt;p&gt;Juxt is one of those weird Clojure functions that just doesn't make sense until you see it in action. However, once you get it, you love it. This short example shows a great use of the juxt function.&lt;/p&gt;&lt;p&gt;What does juxt do? It creates a function that is the application of a list of functions to a single argument. In simpler terms, a typical function returns one result for one input. In the case of juxt, you create a function that returns n results for one input. The n results are computed from the n functions that you juxtapose.&lt;/p&gt;&lt;p&gt;For example, suppose you need both the cosine and sine x for a given application. You could create two separate variables, like so:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn angle-&amp;gt;cartesian
&amp;quot;Convert an angle &amp;#40;in radians&amp;#41; to its cartesian vector equivalent.&amp;quot;
  &amp;#91;theta&amp;#93;
  &amp;#40;let&amp;#91;x &amp;#40;Math/cos theta&amp;#41;
       y &amp;#40;Math/sin theta&amp;#41;&amp;#93;
    &amp;#91;x y&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, it is more convenient to juxtapose (set side by side) the two items being computed into a single vector.&lt;/p&gt;&lt;p&gt;Here's a problem that builds on the above to show how nice juxt is:&lt;/p&gt;&lt;p&gt;You are given two angles in degrees and need to compute the signed distance between them. These angles aren't constrained to [0, 360). If the angles are outside of this range, we want to use the equivalent angle within the desired range. Here are a few examples of the desired output:&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align='center'&gt;First Angle&lt;/th&gt;&lt;th align='center'&gt;Second Angle&lt;/th&gt;&lt;th align='center'&gt;Signed Distance&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align='center'&gt;10&lt;/td&gt;&lt;td align='center'&gt;20&lt;/td&gt;&lt;td align='center'&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;20&lt;/td&gt;&lt;td align='center'&gt;10&lt;/td&gt;&lt;td align='center'&gt;-10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;350&lt;/td&gt;&lt;td align='center'&gt;10&lt;/td&gt;&lt;td align='center'&gt;20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;10&lt;/td&gt;&lt;td align='center'&gt;350&lt;/td&gt;&lt;td align='center'&gt;-20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;-350&lt;/td&gt;&lt;td align='center'&gt;350&lt;/td&gt;&lt;td align='center'&gt;-20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align='center'&gt;350&lt;/td&gt;&lt;td align='center'&gt;-350&lt;/td&gt;&lt;td align='center'&gt;20&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;You can probably solve this problem with some combination of mod, rem, and/or quot, but I find it much easier to simply transform the angles to their cartesian vector form and do the math in that coordinate system. Recall that for unit vectors the dot product of vectors A and B is A*B=cos(Î¸), where Î¸ is the angle between the vectors. Likewise, the sign of the cross product of the vectors indicates the the direction of rotation via the right hand rule. So, I can use dot to compute my angular offset and cross to determine the direction.&lt;/p&gt;&lt;p&gt;With that knowledge, here's my function to compute angular distances: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn angular-delta
&amp;quot;Compute the difference between two angles, 
where angles are in degrees.&amp;quot;
&amp;#91;a b&amp;#93;
&amp;#40;let &amp;#91;&amp;#91;u v&amp;#93; &amp;#40;map &amp;#40;juxt #&amp;#40;Math/cos %&amp;#41; #&amp;#40;Math/sin %&amp;#41;&amp;#41;
                 &amp;#40;map #&amp;#40;Math/toRadians %&amp;#41; &amp;#91;a b&amp;#93;&amp;#41;&amp;#41;
      theta &amp;#40;Math/acos &amp;#40;reduce + &amp;#40;map &amp;#42; u v&amp;#41;&amp;#41;&amp;#41;
      sign &amp;#40;Math/signum &amp;#40;reduce - &amp;#40;map &amp;#42; u &amp;#40;reverse v&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
  &amp;#40;Math/toDegrees &amp;#40;&amp;#42; sign theta&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pretty slick, eh? Notice how the combination of juxt and destructuring (the automagic mapping of the result to the [x y] vector) both shortened my code and created a single vector structure, which communicated my intent. As an afterthought, let me state that I am only converting to degrees since they are easier on the eyes for most humans. In the real world, I'd leave the function in terms of radians since, in the words of my favorite college math professor, &quot;Degrees are for temperature, radians are for math.&quot;&lt;/p&gt;&lt;p&gt;Does this all give the right answer? Let the REPL decide:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn angular-delta
  &amp;quot;Compute the difference between two angles, 
  where angles are in degrees.&amp;quot;
  &amp;#91;a b&amp;#93;
  &amp;#40;let &amp;#91;&amp;#91;u v&amp;#93; &amp;#40;map &amp;#40;juxt #&amp;#40;Math/cos %&amp;#41; #&amp;#40;Math/sin %&amp;#41;&amp;#41;
                   &amp;#40;map #&amp;#40;Math/toRadians %&amp;#41; &amp;#91;a b&amp;#93;&amp;#41;&amp;#41;
        theta &amp;#40;Math/acos &amp;#40;reduce + &amp;#40;map &amp;#42; u v&amp;#41;&amp;#41;&amp;#41;
        sign &amp;#40;Math/signum &amp;#40;reduce - &amp;#40;map &amp;#42; u &amp;#40;reverse v&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;Math/toDegrees &amp;#40;&amp;#42; sign theta&amp;#41;&amp;#41;&amp;#41;&amp;#41;
=&amp;gt; #'user/angular-delta
&amp;#40;angular-delta 10 20&amp;#41;
=&amp;gt; 10.000000000000012
&amp;#40;angular-delta 20 10&amp;#41;
=&amp;gt; -10.000000000000012
&amp;#40;angular-delta 350 10&amp;#41;
=&amp;gt; 20.00000000000001
&amp;#40;angular-delta 10 350&amp;#41;
=&amp;gt; -20.00000000000001
&amp;#40;angular-delta -350 350&amp;#41;
=&amp;gt; -20.00000000000001
&amp;#40;angular-delta 350 -350&amp;#41;
=&amp;gt; 20.00000000000001
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ignoring the precision issues, this gives just the right answer.&lt;/p&gt;&lt;p&gt;I hope this provides a nice explanation of how you might use juxt in a real problem. There are many other similar cases where you need to compute several independent variations of an initial value to perform a computation. Whenever you need do to this, use juxt.&lt;/p&gt;&lt;p&gt;If you liked this page or learned anything from it, please tweet the link and/or follow me on Twitter. Your support and interest is the fuel that drives the effort.&lt;/p&gt;
</description>
<pubDate>
Tue, 31 Mar 2015 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
https://markbastian.github.io/posts-output/2015-03-30-life/
</guid>
<link>
https://markbastian.github.io/posts-output/2015-03-30-life/
</link>
<title>
Conway's Game of Life
</title>
<description>
&lt;h2 id=&quot;the&amp;#95;project&quot;&gt;The Project&lt;/h2&gt;&lt;p&gt;I wanted to create an interesting project in Clojure that had the following features:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The project should be simple, but interesting&lt;/li&gt;&lt;li&gt;The project should demonstrate how Clojure, ClojureScript, and cljx interact&lt;/li&gt;&lt;li&gt;There should be some cool Clojure features to learn about&lt;/li&gt;&lt;li&gt;I wanted to demonstrate how to achieve state in a stateless world &lt;/li&gt;&lt;/ul&gt;&lt;p&gt; I chose to program up Conway's Game of Life, a simple zero-player cellular automaton.   It's a fun little simulation and meets all of my criterion. Here's what it looks like:   &lt;/p&gt;&lt;p&gt;&lt;div&gt; &lt;canvas height=&quot;400&quot; id=&quot;myCanvas&quot; style=&quot;border: 1px solid #000000;&quot; width=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div&gt; &lt;button id=&quot;reset&quot; type=&quot;button&quot;&gt;Reset&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../../js/conway.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;h2 id=&quot;the&amp;#95;rules&quot;&gt;The Rules&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;A living cell with only one or two neighbors dies&lt;/li&gt;&lt;li&gt;A living cell with two or three live neighbors survives&lt;/li&gt;&lt;li&gt;A living cell with greater than three neighbors dies&lt;/li&gt;&lt;li&gt;A dead cell with exactly three neighbors comes to life  &lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;postmortem&quot;&gt;Postmortem&lt;/h2&gt;&lt;h3 id=&quot;implementation&amp;#95;in&amp;#95;clojure&quot;&gt;Implementation in Clojure&lt;/h3&gt;&lt;br /&gt;&lt;p&gt;Conway's Game of Life is a cellular automaton in which a population of cells evolves with the following rules: This project was coded up in Clojure as an example of what can be done using the clj/cljs/cljx integration.  It was done in three main files: rules.cljx, swingui.clj, and canvasui.cljs. Below you will find the complete listing  of the rules and canvasui namespaces. the swingui namespace is available via git here.&lt;/p&gt;&lt;h3 id=&quot;rules.cljx&quot;&gt;rules.cljx&lt;/h3&gt;&lt;p&gt;Here's a listing of the entire &quot;rule engine&quot; for the application.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns conway.rules&amp;#41;

&amp;#40;defn gen-cell&amp;#91;&amp;#93;&amp;#40;if &amp;#40;&amp;gt; &amp;#40;Math/random&amp;#41; 0.7&amp;#41; :alive :dead&amp;#41;&amp;#41;

&amp;#40;defn seed-grid &amp;#91;rows cols&amp;#93;
  &amp;#40;vec &amp;#40;take rows &amp;#40;repeatedly
    &amp;#40;fn &amp;#91;&amp;#93; &amp;#40;vec &amp;#40;take cols &amp;#40;repeatedly gen-cell&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn neighbors &amp;#91;&amp;#91;i j&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;x &amp;#40;&amp;#40;juxt inc inc identity dec dec dec identity inc&amp;#41; i&amp;#41;
        y &amp;#40;&amp;#40;juxt identity inc inc inc identity dec dec dec&amp;#41; j&amp;#41;&amp;#93;
    &amp;#40;map vector x y&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn count-neighbors &amp;#91;grid coord&amp;#93;
  &amp;#40;let &amp;#91;n &amp;#40;map #&amp;#40;get-in grid %&amp;#41; &amp;#40;neighbors coord&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;count &amp;#40;filter #&amp;#40;= % :alive&amp;#41; n&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn sim-step &amp;#91;grid coord&amp;#93;
  &amp;#40;let &amp;#91;n-live &amp;#40;count-neighbors grid coord&amp;#41;&amp;#93;
    &amp;#40;if &amp;#40;= :alive &amp;#40;get-in grid coord&amp;#41;&amp;#41;
      &amp;#40;case n-live
        &amp;#40;2 3&amp;#41; :alive
        :dead&amp;#41;
      &amp;#40;if &amp;#40;= 3 n-live&amp;#41; :alive :dead&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn step &amp;#91;grid&amp;#93;
  &amp;#40;into &amp;#91;&amp;#93; &amp;#40;for &amp;#91;i &amp;#40;range &amp;#40;count grid&amp;#41;&amp;#41;&amp;#93;
          &amp;#40;into &amp;#91;&amp;#93; &amp;#40;for &amp;#91;j &amp;#40;range &amp;#40;count &amp;#40;get grid i&amp;#41;&amp;#41;&amp;#41;&amp;#93;
                  &amp;#40;sim-step grid &amp;#91;i j&amp;#93;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Perhaps the most interesting aspect of this project is the amount of code  (and I mean the small amount) written to do this complete implementation.  I am continually amazed as I write more Clojure about the expressiveness  and conciseness of the language. Another thing to point out about this file  is the cljx extension. By using this, I can write code that cross-compiles  to target both the JVM and the browser via JavaScript. Pretty cool, eh?&lt;/p&gt;&lt;p&gt;Finally, I wanted to point out my favorite function in this program: juxt.  the Clojure juxt function creates a function that performs a sequence of  perations on a single item and returns that result as an indexed data  structure. This is a perfect function for computing the neighbors of a  cell in a grid. This is way better than having 8 sequential function calls  in which you compute steps to the right, upper right, top center, upper  left, and so on.&lt;/p&gt;&lt;h3 id=&quot;canvasui.cljx&quot;&gt;canvasui.cljx&lt;/h3&gt;&lt;p&gt;And here is the complete listing for the canvas UI code.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns conway.canvasui
  &amp;#40;:require &amp;#91;conway.rules :as rules&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn draw-background &amp;#91;canvas ctx&amp;#93;
  &amp;#40;doto ctx
    &amp;#40;&amp;gt; .-fillStyle &amp;#40;set! &amp;quot;#000000&amp;quot;&amp;#41;&amp;#41;
    &amp;#40;.fillRect 0 0 &amp;#40;.-width canvas&amp;#41; &amp;#40;.-height canvas&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn draw-and-update-grid &amp;#91;canvas ctx grid dim&amp;#93;
  &amp;#40;let &amp;#91;dx &amp;#40;/ &amp;#40;.-width canvas&amp;#41; dim&amp;#41;
        dy &amp;#40;/ &amp;#40;.-height canvas&amp;#41; dim&amp;#41;&amp;#93;
    &amp;#40;do
    &amp;#40;draw-background canvas ctx&amp;#41;
    &amp;#40;&amp;gt; ctx .-fillStyle &amp;#40;set! &amp;quot;#00FF00&amp;quot;&amp;#41;&amp;#41;
    &amp;#40;doseq &amp;#91;i &amp;#40;range &amp;#40;count @grid&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;doseq &amp;#91;j &amp;#40;range &amp;#40;count &amp;#40;get @grid i&amp;#41;&amp;#41;&amp;#41;&amp;#93;
        &amp;#40;when &amp;#40;= :alive &amp;#40;get-in @grid &amp;#91;i j&amp;#93;&amp;#41;&amp;#41;
          &amp;#40;.fillRect ctx &amp;#40;&amp;#42; dx i&amp;#41; &amp;#40;&amp;#42; dy j&amp;#41; dx dy&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;swap! grid rules/step&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;set!
  &amp;#40;.-onload js/window&amp;#41;
  &amp;#40;when &amp;#40;and js/document &amp;#40;.-getElementById js/document&amp;#41;&amp;#41;
    &amp;#40;let &amp;#91;cells 50
          grid &amp;#40;atom &amp;#40;rules/seed-grid cells cells&amp;#41;&amp;#41;
          canvas &amp;#40;.getElementById js/document &amp;quot;myCanvas&amp;quot;&amp;#41;
          reset-button &amp;#40;.getElementById js/document &amp;quot;reset&amp;quot;&amp;#41;
          ctx &amp;#40;.getContext canvas &amp;quot;2d&amp;quot;&amp;#41;&amp;#93;
      &amp;#40;do
        &amp;#40;js/setInterval
          #&amp;#40;draw-and-update-grid canvas ctx grid cells&amp;#41; 10&amp;#41;
        &amp;#40;set! &amp;#40;.-onclick reset-button&amp;#41;
          #&amp;#40;reset! grid &amp;#40;rules/seed-grid cells cells&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, it is amazing how few lines of code were written for this demo.&lt;/p&gt;&lt;p&gt;Finally, take a look at how state is managed in the program. Notice that  there are no defs (global variables within the namespace) anywhere. All   of the state is managed by a single atom (line 25) that is created within    the initialization section of the script and is passed to each function.    The draw-and-update-grid function draws and updates the grid    (as you might expect) while the reset button is used to reset the grid.    Since atoms are synchronous, I don't need to worry about any sort of    concurrency problems. It just works.&lt;/p&gt;&lt;p&gt;This is a very common pattern in the Clojure world for designing  applications. You have three elements:   &lt;/p&gt;&lt;ol&gt;&lt;li&gt;A set of rules that can be thought of as an API or DSL for your project. These rules consist only of defns or perhaps defs that define constants.  They are used to transform or analyze a model. They are completely stateless.&lt;/li&gt;&lt;li&gt;A very small number of Clojure concurrency primitives that manage the actual state of the application. In this case, there is only 1 - the grid atom. You  might have other primitives, such as one for preferences, but the number should  be small and separated by concerns.&lt;/li&gt;&lt;li&gt;A user interface layer. It could be Swing, an HTML app using ClojureScript, or just a repl. &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Coming from a background in 10+ years of Java and then about 6 years of Scala,  this was something it took me a while to understand, but now I can't live without.   When I got deep into Scala I really loved it, but had the hardest time figuring out   how to manage state. With Clojure everything is just baked in.  &lt;/p&gt;&lt;h2 id=&quot;in&amp;#95;conclusion&quot;&gt;In Conclusion&lt;/h2&gt; &lt;p&gt; I was able to write up a simple cross-platform application in just a handful of   lines of code using the amazing powers of Clojure, ClojureScript, and the cljx project.   Despite its simplicity, there are some great things to learn from the project.    If you want to see the entire project, check it out &lt;a href='https://github.com/markbastian/conway'&gt;here&lt;/a&gt;    or my entire github repo &lt;a href='https://github.com/markbastian'&gt;here&lt;/a&gt;.    I hope you enjoyed this project and short postmortem.  &lt;/p&gt;&lt;p&gt; If you liked this page or learned anything from it, please tweet the link and/or follow   me on Twitter. I hope to have other projects like this in the future, and your support   and interest is the fuel that drives the effort.&lt;/p&gt;
</description>
<pubDate>
Mon, 30 Mar 2015 00:00:00 -0600
</pubDate>
</item>
</channel>
</rss>
